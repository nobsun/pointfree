Script started on 2023-05-12 08:06:05+09:00 [TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="205" LINES="23"]
[1m[7m%[27m[1m[0m                                                                                                                                                                                                             [0m[27m[24m[J[4mλ.[24m [K[178C[36mmain[39m: [4m~/devel/pointfree[24m[201D[?1h=[?2004hllghci src/PointFree.hs[1m [0m[0m [?1l>[?2004l
GHCi, version 9.2.7: https://www.haskell.org/ghc/  :? for help
Some flags have not been recognized: -XOverloadedRecordDots
Loaded GHCi configuration from /home/nobsun/Dropbox/devel/pointfree/.ghci
[1 of 1] Compiling PointFree        ( src/PointFree.hs, interpreted )

[;1msrc/PointFree.hs:13:5: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m parse error on input ‘|’[0m[0m
[;1m[34m   |[0m[0m
[;1m[34m13 |[0m[0m     [;1m[31m|[0m[0m EVarF Name
[;1m[34m   |[0m[0m[;1m[31m     ^[0m[0m
Failed, no modules loaded.
2023-05-12 08:06:20.11627171
[?1h=>>> :qE[?1l>Leaving GHCi.
[1m[7m%[27m[1m[0m                                                                                                                                                                                                             [0m[27m[24m[J[4mλ.[24m [K[178C[36mmain[39m: [4m~/devel/pointfree[24m[201D[?1h=[?2004heexit[?1l>[?2004l

Script done on 2023-05-12 08:06:51+09:00 [COMMAND_EXIT_CODE="0"]
Script started on 2023-05-16 09:34:03+09:00 [TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="113" LINES="29"]
[1m[7m%[27m[1m[0m                                                                                                                 [0m[27m[24m[J[4mλ.[24m [K[83C[36mfeature[39m: [4m~/devel/pointfree[24m[109D[?1h=[?2004h./start_programming[19Dlghci              [14D[?1l>[?2004l
GHCi, version 9.2.7: https://www.haskell.org/ghc/  :? for help
Some flags have not been recognized: -XOverloadedRecordDots
Loaded GHCi configuration from /home/nobsun/Dropbox/devel/pointfree/.ghci
2023-05-16 09:34:09.48442555
[?1h=>>> :l src/Lib.hsE[?1l>   1    -- # 雛形モジュール
   2    -- このファイルは`stack new`コマンドで自動的に`src/`に挿入されます
   3    -- 
   4    -- ## 言語拡張と`module`宣言
   5    -- 最低限の指定をしてある
   6    {- |
   7    module:       Lib
   8    copyright:    (c) Nobuo Yamashita 2022
   9    license:      BSD-3
  10    maintainer:   nobsun@sampou.org
  11    stability:    experimental
  12    -}
  13    {-# LANGUAGE BangPatterns #-}
  14    {-# LANGUAGE LambdaCase #-}
  15    {-# LANGUAGE MultiWayIf #-}
  16    {-# LANGUAGE OverloadedStrings #-}
  17    {-# LANGUAGE ScopedTypeVariables #-}
  18    module Lib
  19        ( someFunc
  20        ) where
  21    
  22    -- ## `doctest`のための記述と定義本体
  23    -- テストは失敗するように書いてある
  24    
  25    {- | 
  26    「なんか関数」を標準出力に印字する
  27    >>> someFunc
  28    なんか関数
  29    -}
  30    someFunc :: IO ()
  31    someFunc = putStrLn "なんか函数"
[1 of 1] Compiling Lib              ( src/Lib.hs, interpreted )
Ok, one module loaded.
2023-05-16 09:34:15.899824841
[?1h=>>> import TextParser[K[K[K[K[K[K.ParserCombinators.ReadPE[?1l>2023-05-16 09:34:57.117574856
[?1h=>>> import Data.Charl[KE[?1l>2023-05-16 09:35:36.492930787
[?1h=>>> isLower '_'E[?1l>False
2023-05-16 09:35:44.708864901
[?1h=>>> pand = [K[Kp q x = p x && p y p q x = p x && p y[K[19D p q x = p x && p y[K[19D p q x = p x && p y[K[19D p q x = p x && p y[K[19D( p q x = p x && p y[19D| p q x = p x && p y[19D& p q x = p x && p y[19D| p q x = p x && p y[19D) p q x = p x && p y[19D[19CE[?1l>
[;1m<interactive>:5:24: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m Variable not in scope: y[0m[0m
2023-05-16 09:38:12.814024163
[?1h=>>> (|&|) p q x = p x && p y[KxE[?1l>2023-05-16 09:38:22.001904479
[?1h=>>> (|||) p q x = p x || p[Kq [K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K(|&|) p q x = p x && p x x[K[2Dq x[2DE[?1l>2023-05-16 09:38:58.136707027
[?1h=>>> (|||) p q x = p x || q xE[?1l>2023-05-16 09:39:20.075446982
[?1h=>>> :qE[?1l>Leaving GHCi.
[1m[7m%[27m[1m[0m                                                                                                                 [0m[27m[24m[J[4mλ.[24m [K[83C[36mfeature[39m: [4m~/devel/pointfree[24m[109D[?1h=[?2004hlghci src/Expr.hs[?1l>[?2004l
GHCi, version 9.2.7: https://www.haskell.org/ghc/  :? for help
Some flags have not been recognized: -XOverloadedRecordDots
Loaded GHCi configuration from /home/nobsun/Dropbox/devel/pointfree/.ghci
[1 of 1] Compiling Expr             ( src/Expr.hs, interpreted )
Ok, one module loaded.
2023-05-16 09:52:52.938622027
[?1h=>>> E[?1l>Leaving GHCi.
[1m[7m%[27m[1m[0m                                                                                                                 [0m[27m[24m[J[4mλ.[24m [K[83C[36mfeature[39m: [4m~/devel/pointfree[24m[109D[?1h=[?2004hScript started on 2023-05-16 19:41:52+09:00 [TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="313" LINES="30"]
[1m[7m%[27m[1m[0m                                                                                                                                                                                                                                                                                                                         [0m[27m[24m[J[4mλ.[24m [K[275C[36mfeature[39m: [4m~/Dropbox/devel/pointfree[24m[309D[?1h=[?2004hsstack build[?1l>[?2004l
[0mpointfree> build (lib + exe)[0m
[0mPreprocessing library for pointfree-0.1.0.0..[0m
[0mBuilding library for pointfree-0.1.0.0..[0m
[0m[4 of 4] Compiling PointFree[0m
[0mPreprocessing executable 'pointfree' for pointfree-0.1.0.0..[0m
[0mBuilding executable 'pointfree' for pointfree-0.1.0.0..[0m
[0m[1 of 2] Compiling Main [Expr changed][0m
[0m[0m
[0m/home/nobsun/Dropbox/devel/pointfree/[;1mapp/Main.hs:10:7: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m[0m
[0m    • No instance for (Show Expr) arising from a use of ‘print’[0m
[0m    • In a stmt of a 'do' block: print (normalize (pointfree (read a)))[0m
[0m      In the expression:[0m
[0m        do a : _ <- getArgs[0m
[0m           print (normalize (pointfree (read a)))[0m
[0m      In an equation for ‘main’:[0m
[0m          main[0m
[0m            = do a : _ <- getArgs[0m
[0m                 print (normalize (pointfree (read a)))[0m[0m[0m
[0m[;1m[34m   |[0m[0m[0m
[0m[;1m[34m10 |[0m[0m     ; [;1m[31mprint[0m[0m (normalize (pointfree (read a)))[0m
[0m[;1m[34m   |[0m[0m[;1m[31m       ^^^^^[0m[0m[0m
[0m[0m
[0m/home/nobsun/Dropbox/devel/pointfree/[;1mapp/Main.hs:10:36: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m[0m
[0m    • No instance for (Read Expr) arising from a use of ‘read’[0m
[0m    • In the first argument of ‘pointfree’, namely ‘(read a)’[0m
[0m      In the first argument of ‘normalize’, namely ‘(pointfree (read a))’[0m
[0m      In the first argument of ‘print’, namely[0m
[0m        ‘(normalize (pointfree (read a)))’[0m[0m[0m
[0m[;1m[34m   |[0m[0m[0m
[0m[;1m[34m10 |[0m[0m     ; print (normalize (pointfree ([;1m[31mread[0m[0m a)))[0m
[0m[;1m[34m   |[0m[0m[;1m[31m                                    ^^^^[0m[0m[0m
[0m
[91mError:[0m [S-7282]
       Stack failed to execute the build plan.
       
       While executing the build plan, Stack encountered the following errors:
       
       [S-7011]
       While building package [96mpointfree-0.1.0.0[0m (scroll up to its section to see the error) using:
       [95m/home/nobsun/.stack/setup-exe-cache/x86_64-linux-tinfo6/Cabal-simple_SvXsv1f__3.6.3.0_ghc-9.2.7 --verbose=1 --builddir=.stack-work/dist/x86_64-linux-tinfo6/Cabal-3.6.3.0 build lib:pointfree exe:pointfree --ghc-options " -fdiagnostics-color=always"[0m
       Process exited with code: ExitFailure 1 [0m
[1m[7m%[27m[1m[0m                                                                                                                                                                                                                                                                                                                         [0m[27m[24m[J[4mλ.[24m [K[275C[36mfeature[39m: [4m~/Dropbox/devel/pointfree[24m[309D[?1h=[?2004hstack build[?1l>[?2004l
[0mpointfree> build (lib + exe)[0m
[0mPreprocessing library for pointfree-0.1.0.0..[0m
[0mBuilding library for pointfree-0.1.0.0..[0m
[0mPreprocessing executable 'pointfree' for pointfree-0.1.0.0..[0m
[0mBuilding executable 'pointfree' for pointfree-0.1.0.0..[0m
[0m[2 of 2] Compiling Main[0m
[0mLinking .stack-work/dist/x86_64-linux-tinfo6/Cabal-3.6.3.0/build/pointfree/pointfree ...[0m
[0mpointfree> copy/register[0m
[0mInstalling library in /home/nobsun/Dropbox/devel/pointfree/.stack-work/install/x86_64-linux-tinfo6/afc755c786048f55e7efc4be50c775983049562dcf8de728c0692699cfe2d4aa/9.2.7/lib/x86_64-linux-ghc-9.2.7/pointfree-0.1.0.0-B06nRRmntNB6nnOUD79IYj[0m
[0mInstalling executable pointfree in /home/nobsun/Dropbox/devel/pointfree/.stack-work/install/x86_64-linux-tinfo6/afc755c786048f55e7efc4be50c775983049562dcf8de728c0692699cfe2d4aa/9.2.7/bin[0m
[0mRegistering library for pointfree-0.1.0.0..[0m
[1m[7m%[27m[1m[0m                                                                                                                                                                                                                                                                                                                         [0m[27m[24m[J[4mλ.[24m [K[275C[36mfeature[39m: [4m~/Dropbox/devel/pointfree[24m[309D[?1h=[?2004h[?2004l
Script started on 2023-05-16 22:34:56+09:00 [TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="313" LINES="30"]
[1m[7m%[27m[1m[0m                                                                                                                                                                                                                                                                                                                         [0m[27m[24m[J[4mλ.[24m [K[283C[36mfeature[39m: [4m~/devel/pointfree[24m[309D[?1h=[?2004hllghci src/Expr.hs[?1l>[?2004l
GHCi, version 9.2.7: https://www.haskell.org/ghc/  :? for help
Some flags have not been recognized: -XOverloadedRecordDots
Loaded GHCi configuration from /home/nobsun/Dropbox/devel/pointfree/.ghci
[1 of 1] Compiling Expr             ( src/Expr.hs, interpreted )

[;1msrc/Expr.hs:61:15: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m
    Variable not in scope: isInfix :: Name -> Bool[0m[0m
[;1m[34m   |[0m[0m
[;1m[34m61 |[0m[0m             | [;1m[31misInfix[0m[0m o -> pprExpr' s' <+> PP.text o <+> pprExpr' t
[;1m[34m   |[0m[0m[;1m[31m               ^^^^^^^[0m[0m

[;1msrc/Expr.hs:68:11: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m
    Variable not in scope: isInfix :: Name -> Bool[0m[0m
[;1m[34m   |[0m[0m
[;1m[34m68 |[0m[0m         | [;1m[31misInfix[0m[0m o -> PP.parens (PP.text o)
[;1m[34m   |[0m[0m[;1m[31m           ^^^^^^^[0m[0m

[;1msrc/Expr.hs:74:12: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m
    • Variable not in scope: render :: Doc -> String
    • Perhaps you meant ‘PP.render’ (imported from Text.PrettyPrint)
      Perhaps you want to add ‘render’ to the import list
      in the import of ‘Text.PrettyPrint’ (src/Expr.hs:8:1-36).[0m[0m
[;1m[34m   |[0m[0m
[;1m[34m74 |[0m[0m     show = [;1m[31mrender[0m[0m . pprExpr
[;1m[34m   |[0m[0m[;1m[31m            ^^^^^^[0m[0m
Failed, no modules loaded.
2023-05-16 22:35:10.61478623
[?1h=>>> :rE[?1l>   1    module Expr where
   2    
   3    import Data.Bool
   4    import Data.Char
   5    import Data.List (nub)
   6    import Data.Functor.Foldable
   7    import Text.ParserCombinators.ReadP
   8    import Text.PrettyPrint (Doc, (<+>))
   9    import qualified Text.PrettyPrint as PP
  10    
  11    type Name = String
  12    
  13    data Expr
  14        = EVar Name
  15        | ENum Int
  16        | EAp Expr Expr
  17        deriving (Eq)
  18    
  19    isAtom :: Expr -> Bool
  20    isAtom = \ case
  21        EAp _ _ -> False
  22        _       -> True
  23    
  24    data ExprF r
  25        = EVarF Name
  26        | ENumF Int
  27        | EApF r r
  28        deriving (Functor)
  29    
  30    type instance Base Expr = ExprF
  31    
  32    instance Recursive Expr where
  33        project = \ case
  34            EVar v -> EVarF v
  35            ENum n -> ENumF n
  36            EAp s t -> EApF s t
  37    
  38    instance Corecursive Expr where
  39        embed = \ case
  40            EVarF v  -> EVar v
  41            ENumF n  -> ENum n
  42            EApF s t -> EAp s t
  43    
  44    type ScDefn = (Name, [Name], Expr)
  45    
  46    -- Pretty Printer
  47    
  48    pprScDefn :: ScDefn -> PP.Doc
  49    pprScDefn = \ case
  50        (name, vars, expr)
  51            -> PP.text name <+> PP.hsep (map PP.text vars) <+> PP.text "=" <+> pprExpr expr
  52    
  53    pprExpr :: Expr -> PP.Doc
  54    pprExpr = \ case
  55        EVar v  -> PP.text v
  56        ENum n  -> PP.int n
  57        EAp s t -> case s of
  58            ENum _  -> error "number is not a function."
  59            EVar v' -> PP.text v' <+> pprExpr' t
  60            EAp (EVar o) s'
  61                | isInfix o -> pprExpr' s' <+> PP.text o <+> pprExpr' t
  62                | otherwise -> PP.text o <+> pprExpr' s' <+> pprExpr' t
  63            EAp f s'        -> pprExpr f <+> pprExpr' s' <+> pprExpr' t
  64    
  65    pprExpr' :: Expr -> PP.Doc
  66    pprExpr' = \ case
  67        EVar o
  68            | isInfix o -> PP.parens (PP.text o)
  69            | otherwise -> PP.text o
  70        ENum n          -> PP.int n
  71        e               -> PP.parens (pprExpr e)
  72    
  73    isInfix :: String -> Bool
  74    isInfix = all . (`elem` symbols)
  75    
  76    symbols :: String
  77    symbols = ".<>+-*/&|#%^="
  78    
  79    instance Show Expr where
  80        show = PP.render . pprExpr
  81    
[1 of 1] Compiling Expr             ( src/Expr.hs, interpreted )

[;1msrc/Expr.hs:74:11: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m
    • Couldn't match type ‘t0 a0 -> Bool’ with ‘Bool’
      Expected: (a0 -> Bool) -> Bool
        Actual: (a0 -> Bool) -> t0 a0 -> Bool
    • Probable cause: ‘all’ is applied to too few arguments
      In the first argument of ‘(.)’, namely ‘all’
      In the expression: all . (`elem` symbols)
      In an equation for ‘isInfix’: isInfix = all . (`elem` symbols)[0m[0m
[;1m[34m   |[0m[0m
[;1m[34m74 |[0m[0m isInfix = [;1m[31mall[0m[0m . (`elem` symbols)
[;1m[34m   |[0m[0m[;1m[31m           ^^^[0m[0m

[;1msrc/Expr.hs:74:18: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m
    • Couldn't match type ‘Char’ with ‘[Char]’
      Expected: String -> a0 -> Bool
        Actual: Char -> Bool
    • In the second argument of ‘(.)’, namely ‘(`elem` symbols)’
      In the expression: all . (`elem` symbols)
      In an equation for ‘isInfix’: isInfix = all . (`elem` symbols)[0m[0m
[;1m[34m   |[0m[0m
[;1m[34m74 |[0m[0m isInfix = all . ([;1m[31m`elem` symbols[0m[0m)
[;1m[34m   |[0m[0m[;1m[31m                  ^^^^^^^^^^^^^^[0m[0m
Failed, no modules loaded.
2023-05-16 22:39:50.520789574
[?1h=>>> :rE[?1l>   1    module Expr where
   2    
   3    import Data.Bool
   4    import Data.Char
   5    import Data.List (nub)
   6    import Data.Functor.Foldable
   7    import Text.ParserCombinators.ReadP
   8    import Text.PrettyPrint (Doc, (<+>))
   9    import qualified Text.PrettyPrint as PP
  10    
  11    type Name = String
  12    
  13    data Expr
  14        = EVar Name
  15        | ENum Int
  16        | EAp Expr Expr
  17        deriving (Eq)
  18    
  19    isAtom :: Expr -> Bool
  20    isAtom = \ case
  21        EAp _ _ -> False
  22        _       -> True
  23    
  24    data ExprF r
  25        = EVarF Name
  26        | ENumF Int
  27        | EApF r r
  28        deriving (Functor)
  29    
  30    type instance Base Expr = ExprF
  31    
  32    instance Recursive Expr where
  33        project = \ case
  34            EVar v -> EVarF v
  35            ENum n -> ENumF n
  36            EAp s t -> EApF s t
  37    
  38    instance Corecursive Expr where
  39        embed = \ case
  40            EVarF v  -> EVar v
  41            ENumF n  -> ENum n
  42            EApF s t -> EAp s t
  43    
  44    type ScDefn = (Name, [Name], Expr)
  45    
  46    -- Pretty Printer
  47    
  48    pprScDefn :: ScDefn -> PP.Doc
  49    pprScDefn = \ case
  50        (name, vars, expr)
  51            -> PP.text name <+> PP.hsep (map PP.text vars) <+> PP.text "=" <+> pprExpr expr
  52    
  53    pprExpr :: Expr -> PP.Doc
  54    pprExpr = \ case
  55        EVar v  -> PP.text v
  56        ENum n  -> PP.int n
  57        EAp s t -> case s of
  58            ENum _  -> error "number is not a function."
  59            EVar v' -> PP.text v' <+> pprExpr' t
  60            EAp (EVar o) s'
  61                | isInfix o -> pprExpr' s' <+> PP.text o <+> pprExpr' t
  62                | otherwise -> PP.text o <+> pprExpr' s' <+> pprExpr' t
  63            EAp f s'        -> pprExpr f <+> pprExpr' s' <+> pprExpr' t
  64    
  65    pprExpr' :: Expr -> PP.Doc
  66    pprExpr' = \ case
  67        EVar o
  68            | isInfix o -> PP.parens (PP.text o)
  69            | otherwise -> PP.text o
  70        ENum n          -> PP.int n
  71        e               -> PP.parens (pprExpr e)
  72    
  73    isInfix :: String -> Bool
  74    isInfix = all  (`elem` symbols)
  75    
  76    symbols :: String
  77    symbols = ".<>+-*/&|#%^="
  78    
  79    instance Show Expr where
  80        show = PP.render . pprExpr
  81    
[1 of 1] Compiling Expr             ( src/Expr.hs, interpreted )
Ok, one module loaded.
2023-05-16 22:40:12.468040305
[?1h=>>> show $ EAp (EAp (EVar "foldr") (EVar "+")) (EVar "[]")E[?1l>"foldr (+) []"
2023-05-16 22:41:57.496628037
[?1h=>>> >>> >>> >>> 
Script done on 2023-05-16 22:50:27+09:00 [COMMAND_EXIT_CODE="0"]
Script started on 2023-05-17 00:23:38+09:00 [TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="196" LINES="30"]
[1m[7m%[27m[1m[0m                                                                                                                                                                                                    [0m[27m[24m[J[4mλ.[24m [K[166C[36mfeature[39m: [4m~/devel/pointfree[24m[192D[?1h=[?2004h./start_programming[19Dlghci src/Expr.hs  [?1l>[?2004l
GHCi, version 9.2.7: https://www.haskell.org/ghc/  :? for help
Some flags have not been recognized: -XOverloadedRecordDots
Loaded GHCi configuration from /home/nobsun/Dropbox/devel/pointfree/.ghci
[1 of 1] Compiling Expr             ( src/Expr.hs, interpreted )

[;1msrc/Expr.hs:117:10: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m
    Variable not in scope: pfailure :: ReadP Expr[0m[0m
[;1m[34m    |[0m[0m
[;1m[34m117 |[0m[0m pExpr4 = [;1m[31mpfailure[0m[0m
[;1m[34m    |[0m[0m[;1m[31m          ^^^^^^^^[0m[0m
Failed, no modules loaded.
2023-05-17 00:24:12.146329106
[?1h=>>> :rE[?1l>   1    module Expr where
   2    
   3    import Data.Bool
   4    import Data.Char
   5    import Data.List (nub)
   6    import Data.Functor.Foldable
   7    import Text.ParserCombinators.ReadP
   8    import Text.PrettyPrint (Doc, (<+>))
   9    import qualified Text.PrettyPrint as PP
  10    
  11    type Name = String
  12    
  13    data Expr
  14        = EVar Name
  15        | ENum Int
  16        | EAp Expr Expr
  17        deriving (Eq)
  18    
  19    isAtom :: Expr -> Bool
  20    isAtom = \ case
  21        EAp _ _ -> False
  22        _       -> True
  23    
  24    data ExprF r
  25        = EVarF Name
  26        | ENumF Int
  27        | EApF r r
  28        deriving (Functor)
  29    
  30    type instance Base Expr = ExprF
  31    
  32    instance Recursive Expr where
  33        project = \ case
  34            EVar v -> EVarF v
  35            ENum n -> ENumF n
  36            EAp s t -> EApF s t
  37    
  38    instance Corecursive Expr where
  39        embed = \ case
  40            EVarF v  -> EVar v
  41            ENumF n  -> ENum n
  42            EApF s t -> EAp s t
  43    
  44    type ScDefn = (Name, [Name], Expr)
  45    
  46    -- Pretty Printer
  47    
  48    pprScDefn :: ScDefn -> PP.Doc
  49    pprScDefn = \ case
  50        (name, vars, expr)
  51            -> PP.text name <+> PP.hsep (map PP.text vars) <+> PP.text "=" <+> pprExpr expr
  52    
  53    pprExpr :: Expr -> PP.Doc
  54    pprExpr = \ case
  55        EVar v  -> PP.text v
  56        ENum n  -> PP.int n
  57        EAp s t -> case s of
  58            ENum _  -> error "number is not a function."
  59            EVar v' -> PP.text v' <+> pprExpr' t
  60            EAp (EVar o) s'
  61                | isInfix o -> pprExpr' s' <+> PP.text o <+> pprExpr' t
  62                | otherwise -> PP.text o <+> pprExpr' s' <+> pprExpr' t
  63            EAp f s'        -> pprExpr f <+> pprExpr' s' <+> pprExpr' t
  64    
  65    pprExpr' :: Expr -> PP.Doc
  66    pprExpr' = \ case
  67        EVar o
  68            | isInfix o -> PP.parens (PP.text o)
  69            | otherwise -> PP.text o
  70        ENum n          -> PP.int n
  71        e               -> PP.parens (pprExpr e)
  72    
  73    isInfix :: String -> Bool
  74    isInfix = all  (`elem` symbols)
  75    
  76    symbols :: String
  77    symbols = ".<>+-*/&|#%^="
  78    
  79    instance Show Expr where
  80        show = PP.render . pprExpr
  81    
  82    -- Parser
  83    
  84    type BOp = Expr -> Expr -> Expr
  85    
  86    pExpr :: ReadP Expr
  87    pExpr = pExpr1
  88    
  89    pExpr1 :: ReadP Expr
  90    pExpr1 = chainr1 pExpr2 pOp1
  91    
  92    pOp1 :: ReadP BOp
  93    pOp1 = pure (EAp . EAp (EVar "||"))
  94    
  95    pExpr2 :: ReadP Expr
  96    pExpr2 = chainr1 pExpr3 pOp2
  97    
  98    pOp2 :: ReadP BOp
  99    pOp2 = pure (EAp . EAp (EVar "&&"))
 100    
 101    pExpr3 :: ReadP Expr
 102    pExpr3 = chainr1 pExpr4 pOp3
 103    
 104    pOp3 :: ReadP BOp
 105    pOp3 = foldr1 (+++) [ pure (EAp . EAp (EVar op)) | op <- relops ]
 106    
 107    relops :: [String]
 108    relops = [ "<"
 109             , "<="
 110             , ">="
 111             , ">"
 112             , "=="
 113             , "/="
 114             ]
 115    
 116    pExpr4 :: ReadP Expr
 117    pExpr4 = pfail
 118    
[1 of 1] Compiling Expr             ( src/Expr.hs, interpreted )
Ok, one module loaded.
2023-05-17 00:26:01.239548188
[?1h=>>> >>> >>> >>> >>> >>> >>> :rE[?1l>   1    module Expr where
   2    
   3    import Data.Bool
   4    import Data.Char
   5    import Data.List (nub)
   6    import Data.Functor.Foldable
   7    import Text.ParserCombinators.ReadP
   8    import Text.PrettyPrint (Doc, (<+>))
   9    import qualified Text.PrettyPrint as PP
  10    
  11    type Name = String
  12    
  13    data Expr
  14        = EVar Name
  15        | ENum Int
  16        | EAp Expr Expr
  17        deriving (Eq)
  18    
  19    isAtom :: Expr -> Bool
  20    isAtom = \ case
  21        EAp _ _ -> False
  22        _       -> True
  23    
  24    data ExprF r
  25        = EVarF Name
  26        | ENumF Int
  27        | EApF r r
  28        deriving (Functor)
  29    
  30    type instance Base Expr = ExprF
  31    
  32    instance Recursive Expr where
  33        project = \ case
  34            EVar v -> EVarF v
  35            ENum n -> ENumF n
  36            EAp s t -> EApF s t
  37    
  38    instance Corecursive Expr where
  39        embed = \ case
  40            EVarF v  -> EVar v
  41            ENumF n  -> ENum n
  42            EApF s t -> EAp s t
  43    
  44    type ScDefn = (Name, [Name], Expr)
  45    
  46    -- Pretty Printer
  47    
  48    pprScDefn :: ScDefn -> PP.Doc
  49    pprScDefn = \ case
  50        (name, vars, expr)
  51            -> PP.text name <+> PP.hsep (map PP.text vars) <+> PP.text "=" <+> pprExpr expr
  52    
  53    pprExpr :: Expr -> PP.Doc
  54    pprExpr = \ case
  55        EVar v  -> PP.text v
  56        ENum n  -> PP.int n
  57        EAp s t -> case s of
  58            ENum _  -> error "number is not a function."
  59            EVar v' -> PP.text v' <+> pprExpr' t
  60            EAp (EVar o) s'
  61                | isInfix o -> pprExpr' s' <+> PP.text o <+> pprExpr' t
  62                | otherwise -> PP.text o <+> pprExpr' s' <+> pprExpr' t
  63            EAp f s'        -> pprExpr f <+> pprExpr' s' <+> pprExpr' t
  64    
  65    pprExpr' :: Expr -> PP.Doc
  66    pprExpr' = \ case
  67        EVar o
  68            | isInfix o -> PP.parens (PP.text o)
  69            | otherwise -> PP.text o
  70        ENum n          -> PP.int n
  71        e               -> PP.parens (pprExpr e)
  72    
  73    isInfix :: String -> Bool
  74    isInfix = all  (`elem` symbols)
  75    
  76    symbols :: String
  77    symbols = ".<>+-*/&|#%^="
  78    
  79    instance Show Expr where
  80        show = PP.render . pprExpr
  81    
  82    -- Parser
  83    
  84    data PartialExpr
  85        = NoOp
  86        | FoundOp Name Expr
  87    
  88    assembleOp :: Expr -> PartialExpr -> Expr
  89    assembleOp e1 = \ case
  90        NoOp          -> e1
  91        FoundOp op e2 -> EAp (EAp (EVar op) e1) e2
  92    
  93    token :: ReadP a -> ReadP a
  94    token = (skipSpaces *>)
  95    
  96    pExpr :: ReadP Expr
  97    pExpr = undefined
  98    
  99    pBop :: Name -> ReadP (Expr -> Expr -> Expr)
 100    pBop op = (EAp .) . (EAp . EVar) <$> (token (string op))
 101    
 102    relops :: [String]
 103    relops = [ "<"
 104             , "<="
 105             , ">="
 106             , ">"
 107             , "=="
 108             , "/="
 109             ]
 110    
[1 of 1] Compiling Expr             ( src/Expr.hs, interpreted )
Ok, one module loaded.
2023-05-17 10:54:01.117874136
[?1h=>>> :rE[?1l>   1    module Expr where
   2    
   3    import Data.Bool
   4    import Data.Char
   5    import Data.List (nub)
   6    import Data.Functor.Foldable
   7    import Text.ParserCombinators.ReadP
   8    import Text.PrettyPrint (Doc, (<+>))
   9    import qualified Text.PrettyPrint as PP
  10    
  11    type Name = String
  12    
  13    data Expr
  14        = EVar Name
  15        | ENum Int
  16        | EAp Expr Expr
  17        deriving (Eq)
  18    
  19    isAtom :: Expr -> Bool
  20    isAtom = \ case
  21        EAp _ _ -> False
  22        _       -> True
  23    
  24    data ExprF r
  25        = EVarF Name
  26        | ENumF Int
  27        | EApF r r
  28        deriving (Functor)
  29    
  30    type instance Base Expr = ExprF
  31    
  32    instance Recursive Expr where
  33        project = \ case
  34            EVar v -> EVarF v
  35            ENum n -> ENumF n
  36            EAp s t -> EApF s t
  37    
  38    instance Corecursive Expr where
  39        embed = \ case
  40            EVarF v  -> EVar v
  41            ENumF n  -> ENum n
  42            EApF s t -> EAp s t
  43    
  44    type ScDefn = (Name, [Name], Expr)
  45    
  46    -- Pretty Printer
  47    
  48    pprScDefn :: ScDefn -> PP.Doc
  49    pprScDefn = \ case
  50        (name, vars, expr)
  51            -> PP.text name <+> PP.hsep (map PP.text vars) <+> PP.text "=" <+> pprExpr expr
  52    
  53    pprExpr :: Expr -> PP.Doc
  54    pprExpr = \ case
  55        EVar v  -> PP.text v
  56        ENum n  -> PP.int n
  57        EAp s t -> case s of
  58            ENum _  -> error "number is not a function."
  59            EVar v' -> PP.text v' <+> pprExpr' t
  60            EAp (EVar o) s'
  61                | isInfix o -> pprExpr' s' <+> PP.text o <+> pprExpr' t
  62                | otherwise -> PP.text o <+> pprExpr' s' <+> pprExpr' t
  63            EAp f s'        -> pprExpr f <+> pprExpr' s' <+> pprExpr' t
  64    
  65    pprExpr' :: Expr -> PP.Doc
  66    pprExpr' = \ case
  67        EVar o
  68            | isInfix o -> PP.parens (PP.text o)
  69            | otherwise -> PP.text o
  70        ENum n          -> PP.int n
  71        e               -> PP.parens (pprExpr e)
  72    
  73    isInfix :: String -> Bool
  74    isInfix = all  (`elem` symbols)
  75    
  76    symbols :: String
  77    symbols = ".<>+-*/&|#%^="
  78    
  79    instance Show Expr where
  80        show = PP.render . pprExpr
  81    
  82    -- Parser
  83    
  84    data PartialExpr
  85        = NoOp
  86        | FoundOp Name Expr
  87    
  88    assembleOp :: Expr -> PartialExpr -> Expr
  89    assembleOp e1 = \ case
  90        NoOp          -> e1
  91        FoundOp op e2 -> EAp (EAp (EVar op) e1) e2
  92    
  93    token :: ReadP a -> ReadP a
  94    token = (skipSpaces *>)
  95    
  96    pBop :: Name -> ReadP (Expr -> Expr -> Expr)
  97    pBop op = (EAp .) . (EAp . EVar) <$> (token (string op))
  98    
  99    pExpr :: ReadP Expr
 100    pExpr = chainr1 pExpr1 (pBop "||")
 101    
 102    pExpr1 :: ReadP Expr
 103    pExpr1 = pfail
 104    
 105    relops :: [String]
 106    relops = [ "<"
 107             , "<="
 108             , ">="
 109             , ">"
 110             , "=="
 111             , "/="
 112             ]
 113    
[1 of 1] Compiling Expr             ( src/Expr.hs, interpreted )
Ok, one module loaded.
2023-05-17 10:57:17.338923079
[?1h=>>> c[K:qE[?1l>Leaving GHCi.
[1m[7m%[27m[1m[0m                                                                                 [0m[27m[24m[J[4mλ.[24m [K[51C[36mfeature[39m: [4m~/devel/pointfree[24m[77D[?1h=[?2004h[0m[27m[24m[J[4mλ.[24m [K[51C[36mfeature[39m: [4m~/devel/pointfree[24m[77D[0m[27m[24m[J[4mλ.[24m [K[51C[36mfeature[39m: [4m~/devel/pointfree[24m[77Dmmore ../ifl-tut/src/Langua      Parsr er.hs[1m [0m[0m [?1l>[?2004l
[?1h=[H[J                                                                                                                                                                                                                     [1;1H                     
[2;1H                     module Parser
[3;1H                       ( -- * パーザ
[4;1H                         Loc
[5;1H                       , Token
[6;1H                       , tokLoc
[7;1H                       , tokStr
[8;1H                       , Parser
[9;1H                       , pVar
[10;1H                       , pLit
[11;1H                       , pSat
[12;1H                       , pNum
[13;1H                       , pAlt
[14;1H                       , pAlt'
[15;1H                       , (<+)
[16;1H                       , pEmpty
[17;1H                       , pApply
[18;1H                       , pThen, pThen3, pThen4
[19;1H                       , pZeroOrMore, pOneOrMore
[20;1H                       , pMunch, pMunch1
[21;1H                       , pOneOrMoreWithSep
[22;1H                       , (<$$>), (<$$), (<**>), (<**), (**>)
[23;1H                       , takeFirstParse
[24;1H                       ) where
[25;1H                     
[26;1H                     import Data.Char ( isAlpha, isDigit )
[27;1H                     
[28;1H                     {- 構文解析用の基本的ツール -}
[29;1H                     
[30;1H                     type Loc = Int
[31;1H                     type Token = (Loc, String)
[32;1H                     
[33;1H                     tokLoc :: Token -> Loc
[34;1H                     tokLoc = fst
[35;1H                     
[36;1H                     tokStr :: Token -> String
[37;1H                     tokStr = snd
[38;1H                     [K            [7m        ../ifl-tut/src/Parser.hs[m        :[K            [H[J                                                                                                                                                                                                                     [1;1H                     module Parser
[2;1H                       ( -- * パーザ
[3;1H                         Loc
[4;1H                       , Token
[5;1H                       , tokLoc
[6;1H                       , tokStr
[7;1H                       , Parser
[8;1H                       , pVar
[9;1H                       , pLit
[10;1H                       , pSat
[11;1H                       , pNum
[12;1H                       , pAlt
[13;1H                       , pAlt'
[14;1H                       , (<+)
[15;1H                       , pEmpty
[16;1H                       , pApply
[17;1H                       , pThen, pThen3, pThen4
[18;1H                       , pZeroOrMore, pOneOrMore
[19;1H                       , pMunch, pMunch1
[20;1H                       , pOneOrMoreWithSep
[21;1H                       , (<$$>), (<$$), (<**>), (<**), (**>)
[22;1H                       , takeFirstParse
[23;1H                       ) where
[24;1H                     
[25;1H                     import Data.Char ( isAlpha, isDigit )
[26;1H                     
[27;1H                     {- 構文解析用の基本的ツール -}
[28;1H                     
[29;1H                     type Loc = Int
[30;1H                     type Token = (Loc, String)
[31;1H                     
[32;1H                     tokLoc :: Token -> Loc
[33;1H                     tokLoc = fst
[34;1H                     
[35;1H                     tokStr :: Token -> String
[36;1H                     tokStr = snd
[37;1H                     
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                       ( -- * パーザ
[2;1H                         Loc
[3;1H                       , Token
[4;1H                       , tokLoc
[5;1H                       , tokStr
[6;1H                       , Parser
[7;1H                       , pVar
[8;1H                       , pLit
[9;1H                       , pSat
[10;1H                       , pNum
[11;1H                       , pAlt
[12;1H                       , pAlt'
[13;1H                       , (<+)
[14;1H                       , pEmpty
[15;1H                       , pApply
[16;1H                       , pThen, pThen3, pThen4
[17;1H                       , pZeroOrMore, pOneOrMore
[18;1H                       , pMunch, pMunch1
[19;1H                       , pOneOrMoreWithSep
[20;1H                       , (<$$>), (<$$), (<**>), (<**), (**>)
[21;1H                       , takeFirstParse
[22;1H                       ) where
[23;1H                     
[24;1H                     import Data.Char ( isAlpha, isDigit )
[25;1H                     
[26;1H                     {- 構文解析用の基本的ツール -}
[27;1H                     
[28;1H                     type Loc = Int
[29;1H                     type Token = (Loc, String)
[30;1H                     
[31;1H                     tokLoc :: Token -> Loc
[32;1H                     tokLoc = fst
[33;1H                     
[34;1H                     tokStr :: Token -> String
[35;1H                     tokStr = snd
[36;1H                     
[37;1H                     type Parser a = [Token] -> [(a, [Token])]
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                         Loc
[2;1H                       , Token
[3;1H                       , tokLoc
[4;1H                       , tokStr
[5;1H                       , Parser
[6;1H                       , pVar
[7;1H                       , pLit
[8;1H                       , pSat
[9;1H                       , pNum
[10;1H                       , pAlt
[11;1H                       , pAlt'
[12;1H                       , (<+)
[13;1H                       , pEmpty
[14;1H                       , pApply
[15;1H                       , pThen, pThen3, pThen4
[16;1H                       , pZeroOrMore, pOneOrMore
[17;1H                       , pMunch, pMunch1
[18;1H                       , pOneOrMoreWithSep
[19;1H                       , (<$$>), (<$$), (<**>), (<**), (**>)
[20;1H                       , takeFirstParse
[21;1H                       ) where
[22;1H                     
[23;1H                     import Data.Char ( isAlpha, isDigit )
[24;1H                     
[25;1H                     {- 構文解析用の基本的ツール -}
[26;1H                     
[27;1H                     type Loc = Int
[28;1H                     type Token = (Loc, String)
[29;1H                     
[30;1H                     tokLoc :: Token -> Loc
[31;1H                     tokLoc = fst
[32;1H                     
[33;1H                     tokStr :: Token -> String
[34;1H                     tokStr = snd
[35;1H                     
[36;1H                     type Parser a = [Token] -> [(a, [Token])]
[37;1H                     
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                       , Token
[2;1H                       , tokLoc
[3;1H                       , tokStr
[4;1H                       , Parser
[5;1H                       , pVar
[6;1H                       , pLit
[7;1H                       , pSat
[8;1H                       , pNum
[9;1H                       , pAlt
[10;1H                       , pAlt'
[11;1H                       , (<+)
[12;1H                       , pEmpty
[13;1H                       , pApply
[14;1H                       , pThen, pThen3, pThen4
[15;1H                       , pZeroOrMore, pOneOrMore
[16;1H                       , pMunch, pMunch1
[17;1H                       , pOneOrMoreWithSep
[18;1H                       , (<$$>), (<$$), (<**>), (<**), (**>)
[19;1H                       , takeFirstParse
[20;1H                       ) where
[21;1H                     
[22;1H                     import Data.Char ( isAlpha, isDigit )
[23;1H                     
[24;1H                     {- 構文解析用の基本的ツール -}
[25;1H                     
[26;1H                     type Loc = Int
[27;1H                     type Token = (Loc, String)
[28;1H                     
[29;1H                     tokLoc :: Token -> Loc
[30;1H                     tokLoc = fst
[31;1H                     
[32;1H                     tokStr :: Token -> String
[33;1H                     tokStr = snd
[34;1H                     
[35;1H                     type Parser a = [Token] -> [(a, [Token])]
[36;1H                     
[37;1H                     pLit :: String -> Parser String
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                       , tokLoc
[2;1H                       , tokStr
[3;1H                       , Parser
[4;1H                       , pVar
[5;1H                       , pLit
[6;1H                       , pSat
[7;1H                       , pNum
[8;1H                       , pAlt
[9;1H                       , pAlt'
[10;1H                       , (<+)
[11;1H                       , pEmpty
[12;1H                       , pApply
[13;1H                       , pThen, pThen3, pThen4
[14;1H                       , pZeroOrMore, pOneOrMore
[15;1H                       , pMunch, pMunch1
[16;1H                       , pOneOrMoreWithSep
[17;1H                       , (<$$>), (<$$), (<**>), (<**), (**>)
[18;1H                       , takeFirstParse
[19;1H                       ) where
[20;1H                     
[21;1H                     import Data.Char ( isAlpha, isDigit )
[22;1H                     
[23;1H                     {- 構文解析用の基本的ツール -}
[24;1H                     
[25;1H                     type Loc = Int
[26;1H                     type Token = (Loc, String)
[27;1H                     
[28;1H                     tokLoc :: Token -> Loc
[29;1H                     tokLoc = fst
[30;1H                     
[31;1H                     tokStr :: Token -> String
[32;1H                     tokStr = snd
[33;1H                     
[34;1H                     type Parser a = [Token] -> [(a, [Token])]
[35;1H                     
[36;1H                     pLit :: String -> Parser String
[37;1H                     pLit s = pSat (s ==)
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                       , tokStr
[2;1H                       , Parser
[3;1H                       , pVar
[4;1H                       , pLit
[5;1H                       , pSat
[6;1H                       , pNum
[7;1H                       , pAlt
[8;1H                       , pAlt'
[9;1H                       , (<+)
[10;1H                       , pEmpty
[11;1H                       , pApply
[12;1H                       , pThen, pThen3, pThen4
[13;1H                       , pZeroOrMore, pOneOrMore
[14;1H                       , pMunch, pMunch1
[15;1H                       , pOneOrMoreWithSep
[16;1H                       , (<$$>), (<$$), (<**>), (<**), (**>)
[17;1H                       , takeFirstParse
[18;1H                       ) where
[19;1H                     
[20;1H                     import Data.Char ( isAlpha, isDigit )
[21;1H                     
[22;1H                     {- 構文解析用の基本的ツール -}
[23;1H                     
[24;1H                     type Loc = Int
[25;1H                     type Token = (Loc, String)
[26;1H                     
[27;1H                     tokLoc :: Token -> Loc
[28;1H                     tokLoc = fst
[29;1H                     
[30;1H                     tokStr :: Token -> String
[31;1H                     tokStr = snd
[32;1H                     
[33;1H                     type Parser a = [Token] -> [(a, [Token])]
[34;1H                     
[35;1H                     pLit :: String -> Parser String
[36;1H                     pLit s = pSat (s ==)
[37;1H                     
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                       , Parser
[2;1H                       , pVar
[3;1H                       , pLit
[4;1H                       , pSat
[5;1H                       , pNum
[6;1H                       , pAlt
[7;1H                       , pAlt'
[8;1H                       , (<+)
[9;1H                       , pEmpty
[10;1H                       , pApply
[11;1H                       , pThen, pThen3, pThen4
[12;1H                       , pZeroOrMore, pOneOrMore
[13;1H                       , pMunch, pMunch1
[14;1H                       , pOneOrMoreWithSep
[15;1H                       , (<$$>), (<$$), (<**>), (<**), (**>)
[16;1H                       , takeFirstParse
[17;1H                       ) where
[18;1H                     
[19;1H                     import Data.Char ( isAlpha, isDigit )
[20;1H                     
[21;1H                     {- 構文解析用の基本的ツール -}
[22;1H                     
[23;1H                     type Loc = Int
[24;1H                     type Token = (Loc, String)
[25;1H                     
[26;1H                     tokLoc :: Token -> Loc
[27;1H                     tokLoc = fst
[28;1H                     
[29;1H                     tokStr :: Token -> String
[30;1H                     tokStr = snd
[31;1H                     
[32;1H                     type Parser a = [Token] -> [(a, [Token])]
[33;1H                     
[34;1H                     pLit :: String -> Parser String
[35;1H                     pLit s = pSat (s ==)
[36;1H                     
[37;1H                     pSat :: (String -> Bool) -> Parser String
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                       , pVar
[2;1H                       , pLit
[3;1H                       , pSat
[4;1H                       , pNum
[5;1H                       , pAlt
[6;1H                       , pAlt'
[7;1H                       , (<+)
[8;1H                       , pEmpty
[9;1H                       , pApply
[10;1H                       , pThen, pThen3, pThen4
[11;1H                       , pZeroOrMore, pOneOrMore
[12;1H                       , pMunch, pMunch1
[13;1H                       , pOneOrMoreWithSep
[14;1H                       , (<$$>), (<$$), (<**>), (<**), (**>)
[15;1H                       , takeFirstParse
[16;1H                       ) where
[17;1H                     
[18;1H                     import Data.Char ( isAlpha, isDigit )
[19;1H                     
[20;1H                     {- 構文解析用の基本的ツール -}
[21;1H                     
[22;1H                     type Loc = Int
[23;1H                     type Token = (Loc, String)
[24;1H                     
[25;1H                     tokLoc :: Token -> Loc
[26;1H                     tokLoc = fst
[27;1H                     
[28;1H                     tokStr :: Token -> String
[29;1H                     tokStr = snd
[30;1H                     
[31;1H                     type Parser a = [Token] -> [(a, [Token])]
[32;1H                     
[33;1H                     pLit :: String -> Parser String
[34;1H                     pLit s = pSat (s ==)
[35;1H                     
[36;1H                     pSat :: (String -> Bool) -> Parser String
[37;1H                     pSat p str = case str of
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                       , pLit
[2;1H                       , pSat
[3;1H                       , pNum
[4;1H                       , pAlt
[5;1H                       , pAlt'
[6;1H                       , (<+)
[7;1H                       , pEmpty
[8;1H                       , pApply
[9;1H                       , pThen, pThen3, pThen4
[10;1H                       , pZeroOrMore, pOneOrMore
[11;1H                       , pMunch, pMunch1
[12;1H                       , pOneOrMoreWithSep
[13;1H                       , (<$$>), (<$$), (<**>), (<**), (**>)
[14;1H                       , takeFirstParse
[15;1H                       ) where
[16;1H                     
[17;1H                     import Data.Char ( isAlpha, isDigit )
[18;1H                     
[19;1H                     {- 構文解析用の基本的ツール -}
[20;1H                     
[21;1H                     type Loc = Int
[22;1H                     type Token = (Loc, String)
[23;1H                     
[24;1H                     tokLoc :: Token -> Loc
[25;1H                     tokLoc = fst
[26;1H                     
[27;1H                     tokStr :: Token -> String
[28;1H                     tokStr = snd
[29;1H                     
[30;1H                     type Parser a = [Token] -> [(a, [Token])]
[31;1H                     
[32;1H                     pLit :: String -> Parser String
[33;1H                     pLit s = pSat (s ==)
[34;1H                     
[35;1H                     pSat :: (String -> Bool) -> Parser String
[36;1H                     pSat p str = case str of
[37;1H                       (_, s) : toks
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                       , pSat
[2;1H                       , pNum
[3;1H                       , pAlt
[4;1H                       , pAlt'
[5;1H                       , (<+)
[6;1H                       , pEmpty
[7;1H                       , pApply
[8;1H                       , pThen, pThen3, pThen4
[9;1H                       , pZeroOrMore, pOneOrMore
[10;1H                       , pMunch, pMunch1
[11;1H                       , pOneOrMoreWithSep
[12;1H                       , (<$$>), (<$$), (<**>), (<**), (**>)
[13;1H                       , takeFirstParse
[14;1H                       ) where
[15;1H                     
[16;1H                     import Data.Char ( isAlpha, isDigit )
[17;1H                     
[18;1H                     {- 構文解析用の基本的ツール -}
[19;1H                     
[20;1H                     type Loc = Int
[21;1H                     type Token = (Loc, String)
[22;1H                     
[23;1H                     tokLoc :: Token -> Loc
[24;1H                     tokLoc = fst
[25;1H                     
[26;1H                     tokStr :: Token -> String
[27;1H                     tokStr = snd
[28;1H                     
[29;1H                     type Parser a = [Token] -> [(a, [Token])]
[30;1H                     
[31;1H                     pLit :: String -> Parser String
[32;1H                     pLit s = pSat (s ==)
[33;1H                     
[34;1H                     pSat :: (String -> Bool) -> Parser String
[35;1H                     pSat p str = case str of
[36;1H                       (_, s) : toks
[37;1H                         | p s       -> [(s,toks)]
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                       , pNum
[2;1H                       , pAlt
[3;1H                       , pAlt'
[4;1H                       , (<+)
[5;1H                       , pEmpty
[6;1H                       , pApply
[7;1H                       , pThen, pThen3, pThen4
[8;1H                       , pZeroOrMore, pOneOrMore
[9;1H                       , pMunch, pMunch1
[10;1H                       , pOneOrMoreWithSep
[11;1H                       , (<$$>), (<$$), (<**>), (<**), (**>)
[12;1H                       , takeFirstParse
[13;1H                       ) where
[14;1H                     
[15;1H                     import Data.Char ( isAlpha, isDigit )
[16;1H                     
[17;1H                     {- 構文解析用の基本的ツール -}
[18;1H                     
[19;1H                     type Loc = Int
[20;1H                     type Token = (Loc, String)
[21;1H                     
[22;1H                     tokLoc :: Token -> Loc
[23;1H                     tokLoc = fst
[24;1H                     
[25;1H                     tokStr :: Token -> String
[26;1H                     tokStr = snd
[27;1H                     
[28;1H                     type Parser a = [Token] -> [(a, [Token])]
[29;1H                     
[30;1H                     pLit :: String -> Parser String
[31;1H                     pLit s = pSat (s ==)
[32;1H                     
[33;1H                     pSat :: (String -> Bool) -> Parser String
[34;1H                     pSat p str = case str of
[35;1H                       (_, s) : toks
[36;1H                         | p s       -> [(s,toks)]
[37;1H                       _             -> []
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                       , pAlt
[2;1H                       , pAlt'
[3;1H                       , (<+)
[4;1H                       , pEmpty
[5;1H                       , pApply
[6;1H                       , pThen, pThen3, pThen4
[7;1H                       , pZeroOrMore, pOneOrMore
[8;1H                       , pMunch, pMunch1
[9;1H                       , pOneOrMoreWithSep
[10;1H                       , (<$$>), (<$$), (<**>), (<**), (**>)
[11;1H                       , takeFirstParse
[12;1H                       ) where
[13;1H                     
[14;1H                     import Data.Char ( isAlpha, isDigit )
[15;1H                     
[16;1H                     {- 構文解析用の基本的ツール -}
[17;1H                     
[18;1H                     type Loc = Int
[19;1H                     type Token = (Loc, String)
[20;1H                     
[21;1H                     tokLoc :: Token -> Loc
[22;1H                     tokLoc = fst
[23;1H                     
[24;1H                     tokStr :: Token -> String
[25;1H                     tokStr = snd
[26;1H                     
[27;1H                     type Parser a = [Token] -> [(a, [Token])]
[28;1H                     
[29;1H                     pLit :: String -> Parser String
[30;1H                     pLit s = pSat (s ==)
[31;1H                     
[32;1H                     pSat :: (String -> Bool) -> Parser String
[33;1H                     pSat p str = case str of
[34;1H                       (_, s) : toks
[35;1H                         | p s       -> [(s,toks)]
[36;1H                       _             -> []
[37;1H                     
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                       , pAlt'
[2;1H                       , (<+)
[3;1H                       , pEmpty
[4;1H                       , pApply
[5;1H                       , pThen, pThen3, pThen4
[6;1H                       , pZeroOrMore, pOneOrMore
[7;1H                       , pMunch, pMunch1
[8;1H                       , pOneOrMoreWithSep
[9;1H                       , (<$$>), (<$$), (<**>), (<**), (**>)
[10;1H                       , takeFirstParse
[11;1H                       ) where
[12;1H                     
[13;1H                     import Data.Char ( isAlpha, isDigit )
[14;1H                     
[15;1H                     {- 構文解析用の基本的ツール -}
[16;1H                     
[17;1H                     type Loc = Int
[18;1H                     type Token = (Loc, String)
[19;1H                     
[20;1H                     tokLoc :: Token -> Loc
[21;1H                     tokLoc = fst
[22;1H                     
[23;1H                     tokStr :: Token -> String
[24;1H                     tokStr = snd
[25;1H                     
[26;1H                     type Parser a = [Token] -> [(a, [Token])]
[27;1H                     
[28;1H                     pLit :: String -> Parser String
[29;1H                     pLit s = pSat (s ==)
[30;1H                     
[31;1H                     pSat :: (String -> Bool) -> Parser String
[32;1H                     pSat p str = case str of
[33;1H                       (_, s) : toks
[34;1H                         | p s       -> [(s,toks)]
[35;1H                       _             -> []
[36;1H                     
[37;1H                     pVar :: Parser String
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                       , (<+)
[2;1H                       , pEmpty
[3;1H                       , pApply
[4;1H                       , pThen, pThen3, pThen4
[5;1H                       , pZeroOrMore, pOneOrMore
[6;1H                       , pMunch, pMunch1
[7;1H                       , pOneOrMoreWithSep
[8;1H                       , (<$$>), (<$$), (<**>), (<**), (**>)
[9;1H                       , takeFirstParse
[10;1H                       ) where
[11;1H                     
[12;1H                     import Data.Char ( isAlpha, isDigit )
[13;1H                     
[14;1H                     {- 構文解析用の基本的ツール -}
[15;1H                     
[16;1H                     type Loc = Int
[17;1H                     type Token = (Loc, String)
[18;1H                     
[19;1H                     tokLoc :: Token -> Loc
[20;1H                     tokLoc = fst
[21;1H                     
[22;1H                     tokStr :: Token -> String
[23;1H                     tokStr = snd
[24;1H                     
[25;1H                     type Parser a = [Token] -> [(a, [Token])]
[26;1H                     
[27;1H                     pLit :: String -> Parser String
[28;1H                     pLit s = pSat (s ==)
[29;1H                     
[30;1H                     pSat :: (String -> Bool) -> Parser String
[31;1H                     pSat p str = case str of
[32;1H                       (_, s) : toks
[33;1H                         | p s       -> [(s,toks)]
[34;1H                       _             -> []
[35;1H                     
[36;1H                     pVar :: Parser String
[37;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                       , pEmpty
[2;1H                       , pApply
[3;1H                       , pThen, pThen3, pThen4
[4;1H                       , pZeroOrMore, pOneOrMore
[5;1H                       , pMunch, pMunch1
[6;1H                       , pOneOrMoreWithSep
[7;1H                       , (<$$>), (<$$), (<**>), (<**), (**>)
[8;1H                       , takeFirstParse
[9;1H                       ) where
[10;1H                     
[11;1H                     import Data.Char ( isAlpha, isDigit )
[12;1H                     
[13;1H                     {- 構文解析用の基本的ツール -}
[14;1H                     
[15;1H                     type Loc = Int
[16;1H                     type Token = (Loc, String)
[17;1H                     
[18;1H                     tokLoc :: Token -> Loc
[19;1H                     tokLoc = fst
[20;1H                     
[21;1H                     tokStr :: Token -> String
[22;1H                     tokStr = snd
[23;1H                     
[24;1H                     type Parser a = [Token] -> [(a, [Token])]
[25;1H                     
[26;1H                     pLit :: String -> Parser String
[27;1H                     pLit s = pSat (s ==)
[28;1H                     
[29;1H                     pSat :: (String -> Bool) -> Parser String
[30;1H                     pSat p str = case str of
[31;1H                       (_, s) : toks
[32;1H                         | p s       -> [(s,toks)]
[33;1H                       _             -> []
[34;1H                     
[35;1H                     pVar :: Parser String
[36;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[37;1H                     
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                       , pApply
[2;1H                       , pThen, pThen3, pThen4
[3;1H                       , pZeroOrMore, pOneOrMore
[4;1H                       , pMunch, pMunch1
[5;1H                       , pOneOrMoreWithSep
[6;1H                       , (<$$>), (<$$), (<**>), (<**), (**>)
[7;1H                       , takeFirstParse
[8;1H                       ) where
[9;1H                     
[10;1H                     import Data.Char ( isAlpha, isDigit )
[11;1H                     
[12;1H                     {- 構文解析用の基本的ツール -}
[13;1H                     
[14;1H                     type Loc = Int
[15;1H                     type Token = (Loc, String)
[16;1H                     
[17;1H                     tokLoc :: Token -> Loc
[18;1H                     tokLoc = fst
[19;1H                     
[20;1H                     tokStr :: Token -> String
[21;1H                     tokStr = snd
[22;1H                     
[23;1H                     type Parser a = [Token] -> [(a, [Token])]
[24;1H                     
[25;1H                     pLit :: String -> Parser String
[26;1H                     pLit s = pSat (s ==)
[27;1H                     
[28;1H                     pSat :: (String -> Bool) -> Parser String
[29;1H                     pSat p str = case str of
[30;1H                       (_, s) : toks
[31;1H                         | p s       -> [(s,toks)]
[32;1H                       _             -> []
[33;1H                     
[34;1H                     pVar :: Parser String
[35;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[36;1H                     
[37;1H                     keywords :: [String]
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                       , pThen, pThen3, pThen4
[2;1H                       , pZeroOrMore, pOneOrMore
[3;1H                       , pMunch, pMunch1
[4;1H                       , pOneOrMoreWithSep
[5;1H                       , (<$$>), (<$$), (<**>), (<**), (**>)
[6;1H                       , takeFirstParse
[7;1H                       ) where
[8;1H                     
[9;1H                     import Data.Char ( isAlpha, isDigit )
[10;1H                     
[11;1H                     {- 構文解析用の基本的ツール -}
[12;1H                     
[13;1H                     type Loc = Int
[14;1H                     type Token = (Loc, String)
[15;1H                     
[16;1H                     tokLoc :: Token -> Loc
[17;1H                     tokLoc = fst
[18;1H                     
[19;1H                     tokStr :: Token -> String
[20;1H                     tokStr = snd
[21;1H                     
[22;1H                     type Parser a = [Token] -> [(a, [Token])]
[23;1H                     
[24;1H                     pLit :: String -> Parser String
[25;1H                     pLit s = pSat (s ==)
[26;1H                     
[27;1H                     pSat :: (String -> Bool) -> Parser String
[28;1H                     pSat p str = case str of
[29;1H                       (_, s) : toks
[30;1H                         | p s       -> [(s,toks)]
[31;1H                       _             -> []
[32;1H                     
[33;1H                     pVar :: Parser String
[34;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[35;1H                     
[36;1H                     keywords :: [String]
[37;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                       , pZeroOrMore, pOneOrMore
[2;1H                       , pMunch, pMunch1
[3;1H                       , pOneOrMoreWithSep
[4;1H                       , (<$$>), (<$$), (<**>), (<**), (**>)
[5;1H                       , takeFirstParse
[6;1H                       ) where
[7;1H                     
[8;1H                     import Data.Char ( isAlpha, isDigit )
[9;1H                     
[10;1H                     {- 構文解析用の基本的ツール -}
[11;1H                     
[12;1H                     type Loc = Int
[13;1H                     type Token = (Loc, String)
[14;1H                     
[15;1H                     tokLoc :: Token -> Loc
[16;1H                     tokLoc = fst
[17;1H                     
[18;1H                     tokStr :: Token -> String
[19;1H                     tokStr = snd
[20;1H                     
[21;1H                     type Parser a = [Token] -> [(a, [Token])]
[22;1H                     
[23;1H                     pLit :: String -> Parser String
[24;1H                     pLit s = pSat (s ==)
[25;1H                     
[26;1H                     pSat :: (String -> Bool) -> Parser String
[27;1H                     pSat p str = case str of
[28;1H                       (_, s) : toks
[29;1H                         | p s       -> [(s,toks)]
[30;1H                       _             -> []
[31;1H                     
[32;1H                     pVar :: Parser String
[33;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[34;1H                     
[35;1H                     keywords :: [String]
[36;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[37;1H                     
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                       , pMunch, pMunch1
[2;1H                       , pOneOrMoreWithSep
[3;1H                       , (<$$>), (<$$), (<**>), (<**), (**>)
[4;1H                       , takeFirstParse
[5;1H                       ) where
[6;1H                     
[7;1H                     import Data.Char ( isAlpha, isDigit )
[8;1H                     
[9;1H                     {- 構文解析用の基本的ツール -}
[10;1H                     
[11;1H                     type Loc = Int
[12;1H                     type Token = (Loc, String)
[13;1H                     
[14;1H                     tokLoc :: Token -> Loc
[15;1H                     tokLoc = fst
[16;1H                     
[17;1H                     tokStr :: Token -> String
[18;1H                     tokStr = snd
[19;1H                     
[20;1H                     type Parser a = [Token] -> [(a, [Token])]
[21;1H                     
[22;1H                     pLit :: String -> Parser String
[23;1H                     pLit s = pSat (s ==)
[24;1H                     
[25;1H                     pSat :: (String -> Bool) -> Parser String
[26;1H                     pSat p str = case str of
[27;1H                       (_, s) : toks
[28;1H                         | p s       -> [(s,toks)]
[29;1H                       _             -> []
[30;1H                     
[31;1H                     pVar :: Parser String
[32;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[33;1H                     
[34;1H                     keywords :: [String]
[35;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[36;1H                     
[37;1H                     pNum :: Parser Int
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                       , pOneOrMoreWithSep
[2;1H                       , (<$$>), (<$$), (<**>), (<**), (**>)
[3;1H                       , takeFirstParse
[4;1H                       ) where
[5;1H                     
[6;1H                     import Data.Char ( isAlpha, isDigit )
[7;1H                     
[8;1H                     {- 構文解析用の基本的ツール -}
[9;1H                     
[10;1H                     type Loc = Int
[11;1H                     type Token = (Loc, String)
[12;1H                     
[13;1H                     tokLoc :: Token -> Loc
[14;1H                     tokLoc = fst
[15;1H                     
[16;1H                     tokStr :: Token -> String
[17;1H                     tokStr = snd
[18;1H                     
[19;1H                     type Parser a = [Token] -> [(a, [Token])]
[20;1H                     
[21;1H                     pLit :: String -> Parser String
[22;1H                     pLit s = pSat (s ==)
[23;1H                     
[24;1H                     pSat :: (String -> Bool) -> Parser String
[25;1H                     pSat p str = case str of
[26;1H                       (_, s) : toks
[27;1H                         | p s       -> [(s,toks)]
[28;1H                       _             -> []
[29;1H                     
[30;1H                     pVar :: Parser String
[31;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[32;1H                     
[33;1H                     keywords :: [String]
[34;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[35;1H                     
[36;1H                     pNum :: Parser Int
[37;1H                     pNum = read <$$> pSat (all isDigit)
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                       , (<$$>), (<$$), (<**>), (<**), (**>)
[2;1H                       , takeFirstParse
[3;1H                       ) where
[4;1H                     
[5;1H                     import Data.Char ( isAlpha, isDigit )
[6;1H                     
[7;1H                     {- 構文解析用の基本的ツール -}
[8;1H                     
[9;1H                     type Loc = Int
[10;1H                     type Token = (Loc, String)
[11;1H                     
[12;1H                     tokLoc :: Token -> Loc
[13;1H                     tokLoc = fst
[14;1H                     
[15;1H                     tokStr :: Token -> String
[16;1H                     tokStr = snd
[17;1H                     
[18;1H                     type Parser a = [Token] -> [(a, [Token])]
[19;1H                     
[20;1H                     pLit :: String -> Parser String
[21;1H                     pLit s = pSat (s ==)
[22;1H                     
[23;1H                     pSat :: (String -> Bool) -> Parser String
[24;1H                     pSat p str = case str of
[25;1H                       (_, s) : toks
[26;1H                         | p s       -> [(s,toks)]
[27;1H                       _             -> []
[28;1H                     
[29;1H                     pVar :: Parser String
[30;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[31;1H                     
[32;1H                     keywords :: [String]
[33;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[34;1H                     
[35;1H                     pNum :: Parser Int
[36;1H                     pNum = read <$$> pSat (all isDigit)
[37;1H                     
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                       , takeFirstParse
[2;1H                       ) where
[3;1H                     
[4;1H                     import Data.Char ( isAlpha, isDigit )
[5;1H                     
[6;1H                     {- 構文解析用の基本的ツール -}
[7;1H                     
[8;1H                     type Loc = Int
[9;1H                     type Token = (Loc, String)
[10;1H                     
[11;1H                     tokLoc :: Token -> Loc
[12;1H                     tokLoc = fst
[13;1H                     
[14;1H                     tokStr :: Token -> String
[15;1H                     tokStr = snd
[16;1H                     
[17;1H                     type Parser a = [Token] -> [(a, [Token])]
[18;1H                     
[19;1H                     pLit :: String -> Parser String
[20;1H                     pLit s = pSat (s ==)
[21;1H                     
[22;1H                     pSat :: (String -> Bool) -> Parser String
[23;1H                     pSat p str = case str of
[24;1H                       (_, s) : toks
[25;1H                         | p s       -> [(s,toks)]
[26;1H                       _             -> []
[27;1H                     
[28;1H                     pVar :: Parser String
[29;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[30;1H                     
[31;1H                     keywords :: [String]
[32;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[33;1H                     
[34;1H                     pNum :: Parser Int
[35;1H                     pNum = read <$$> pSat (all isDigit)
[36;1H                     
[37;1H                     pAlt :: Parser a -> Parser a -> Parser a
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                       ) where
[2;1H                     
[3;1H                     import Data.Char ( isAlpha, isDigit )
[4;1H                     
[5;1H                     {- 構文解析用の基本的ツール -}
[6;1H                     
[7;1H                     type Loc = Int
[8;1H                     type Token = (Loc, String)
[9;1H                     
[10;1H                     tokLoc :: Token -> Loc
[11;1H                     tokLoc = fst
[12;1H                     
[13;1H                     tokStr :: Token -> String
[14;1H                     tokStr = snd
[15;1H                     
[16;1H                     type Parser a = [Token] -> [(a, [Token])]
[17;1H                     
[18;1H                     pLit :: String -> Parser String
[19;1H                     pLit s = pSat (s ==)
[20;1H                     
[21;1H                     pSat :: (String -> Bool) -> Parser String
[22;1H                     pSat p str = case str of
[23;1H                       (_, s) : toks
[24;1H                         | p s       -> [(s,toks)]
[25;1H                       _             -> []
[26;1H                     
[27;1H                     pVar :: Parser String
[28;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[29;1H                     
[30;1H                     keywords :: [String]
[31;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[32;1H                     
[33;1H                     pNum :: Parser Int
[34;1H                     pNum = read <$$> pSat (all isDigit)
[35;1H                     
[36;1H                     pAlt :: Parser a -> Parser a -> Parser a
[37;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     
[2;1H                     import Data.Char ( isAlpha, isDigit )
[3;1H                     
[4;1H                     {- 構文解析用の基本的ツール -}
[5;1H                     
[6;1H                     type Loc = Int
[7;1H                     type Token = (Loc, String)
[8;1H                     
[9;1H                     tokLoc :: Token -> Loc
[10;1H                     tokLoc = fst
[11;1H                     
[12;1H                     tokStr :: Token -> String
[13;1H                     tokStr = snd
[14;1H                     
[15;1H                     type Parser a = [Token] -> [(a, [Token])]
[16;1H                     
[17;1H                     pLit :: String -> Parser String
[18;1H                     pLit s = pSat (s ==)
[19;1H                     
[20;1H                     pSat :: (String -> Bool) -> Parser String
[21;1H                     pSat p str = case str of
[22;1H                       (_, s) : toks
[23;1H                         | p s       -> [(s,toks)]
[24;1H                       _             -> []
[25;1H                     
[26;1H                     pVar :: Parser String
[27;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[28;1H                     
[29;1H                     keywords :: [String]
[30;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[31;1H                     
[32;1H                     pNum :: Parser Int
[33;1H                     pNum = read <$$> pSat (all isDigit)
[34;1H                     
[35;1H                     pAlt :: Parser a -> Parser a -> Parser a
[36;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[37;1H                     
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     import Data.Char ( isAlpha, isDigit )
[2;1H                     
[3;1H                     {- 構文解析用の基本的ツール -}
[4;1H                     
[5;1H                     type Loc = Int
[6;1H                     type Token = (Loc, String)
[7;1H                     
[8;1H                     tokLoc :: Token -> Loc
[9;1H                     tokLoc = fst
[10;1H                     
[11;1H                     tokStr :: Token -> String
[12;1H                     tokStr = snd
[13;1H                     
[14;1H                     type Parser a = [Token] -> [(a, [Token])]
[15;1H                     
[16;1H                     pLit :: String -> Parser String
[17;1H                     pLit s = pSat (s ==)
[18;1H                     
[19;1H                     pSat :: (String -> Bool) -> Parser String
[20;1H                     pSat p str = case str of
[21;1H                       (_, s) : toks
[22;1H                         | p s       -> [(s,toks)]
[23;1H                       _             -> []
[24;1H                     
[25;1H                     pVar :: Parser String
[26;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[27;1H                     
[28;1H                     keywords :: [String]
[29;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[30;1H                     
[31;1H                     pNum :: Parser Int
[32;1H                     pNum = read <$$> pSat (all isDigit)
[33;1H                     
[34;1H                     pAlt :: Parser a -> Parser a -> Parser a
[35;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[36;1H                     
[37;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     
[2;1H                     {- 構文解析用の基本的ツール -}
[3;1H                     
[4;1H                     type Loc = Int
[5;1H                     type Token = (Loc, String)
[6;1H                     
[7;1H                     tokLoc :: Token -> Loc
[8;1H                     tokLoc = fst
[9;1H                     
[10;1H                     tokStr :: Token -> String
[11;1H                     tokStr = snd
[12;1H                     
[13;1H                     type Parser a = [Token] -> [(a, [Token])]
[14;1H                     
[15;1H                     pLit :: String -> Parser String
[16;1H                     pLit s = pSat (s ==)
[17;1H                     
[18;1H                     pSat :: (String -> Bool) -> Parser String
[19;1H                     pSat p str = case str of
[20;1H                       (_, s) : toks
[21;1H                         | p s       -> [(s,toks)]
[22;1H                       _             -> []
[23;1H                     
[24;1H                     pVar :: Parser String
[25;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[26;1H                     
[27;1H                     keywords :: [String]
[28;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[29;1H                     
[30;1H                     pNum :: Parser Int
[31;1H                     pNum = read <$$> pSat (all isDigit)
[32;1H                     
[33;1H                     pAlt :: Parser a -> Parser a -> Parser a
[34;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[35;1H                     
[36;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[37;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     {- 構文解析用の基本的ツール -}
[2;1H                     
[3;1H                     type Loc = Int
[4;1H                     type Token = (Loc, String)
[5;1H                     
[6;1H                     tokLoc :: Token -> Loc
[7;1H                     tokLoc = fst
[8;1H                     
[9;1H                     tokStr :: Token -> String
[10;1H                     tokStr = snd
[11;1H                     
[12;1H                     type Parser a = [Token] -> [(a, [Token])]
[13;1H                     
[14;1H                     pLit :: String -> Parser String
[15;1H                     pLit s = pSat (s ==)
[16;1H                     
[17;1H                     pSat :: (String -> Bool) -> Parser String
[18;1H                     pSat p str = case str of
[19;1H                       (_, s) : toks
[20;1H                         | p s       -> [(s,toks)]
[21;1H                       _             -> []
[22;1H                     
[23;1H                     pVar :: Parser String
[24;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[25;1H                     
[26;1H                     keywords :: [String]
[27;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[28;1H                     
[29;1H                     pNum :: Parser Int
[30;1H                     pNum = read <$$> pSat (all isDigit)
[31;1H                     
[32;1H                     pAlt :: Parser a -> Parser a -> Parser a
[33;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[34;1H                     
[35;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[36;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[37;1H                     
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     
[2;1H                     type Loc = Int
[3;1H                     type Token = (Loc, String)
[4;1H                     
[5;1H                     tokLoc :: Token -> Loc
[6;1H                     tokLoc = fst
[7;1H                     
[8;1H                     tokStr :: Token -> String
[9;1H                     tokStr = snd
[10;1H                     
[11;1H                     type Parser a = [Token] -> [(a, [Token])]
[12;1H                     
[13;1H                     pLit :: String -> Parser String
[14;1H                     pLit s = pSat (s ==)
[15;1H                     
[16;1H                     pSat :: (String -> Bool) -> Parser String
[17;1H                     pSat p str = case str of
[18;1H                       (_, s) : toks
[19;1H                         | p s       -> [(s,toks)]
[20;1H                       _             -> []
[21;1H                     
[22;1H                     pVar :: Parser String
[23;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[24;1H                     
[25;1H                     keywords :: [String]
[26;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[27;1H                     
[28;1H                     pNum :: Parser Int
[29;1H                     pNum = read <$$> pSat (all isDigit)
[30;1H                     
[31;1H                     pAlt :: Parser a -> Parser a -> Parser a
[32;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[33;1H                     
[34;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[35;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[36;1H                     
[37;1H                     infixr 3 `pAlt`, `pAlt'`
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     type Loc = Int
[2;1H                     type Token = (Loc, String)
[3;1H                     
[4;1H                     tokLoc :: Token -> Loc
[5;1H                     tokLoc = fst
[6;1H                     
[7;1H                     tokStr :: Token -> String
[8;1H                     tokStr = snd
[9;1H                     
[10;1H                     type Parser a = [Token] -> [(a, [Token])]
[11;1H                     
[12;1H                     pLit :: String -> Parser String
[13;1H                     pLit s = pSat (s ==)
[14;1H                     
[15;1H                     pSat :: (String -> Bool) -> Parser String
[16;1H                     pSat p str = case str of
[17;1H                       (_, s) : toks
[18;1H                         | p s       -> [(s,toks)]
[19;1H                       _             -> []
[20;1H                     
[21;1H                     pVar :: Parser String
[22;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[23;1H                     
[24;1H                     keywords :: [String]
[25;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[26;1H                     
[27;1H                     pNum :: Parser Int
[28;1H                     pNum = read <$$> pSat (all isDigit)
[29;1H                     
[30;1H                     pAlt :: Parser a -> Parser a -> Parser a
[31;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[32;1H                     
[33;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[34;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[35;1H                     
[36;1H                     infixr 3 `pAlt`, `pAlt'`
[37;1H                     
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     type Token = (Loc, String)
[2;1H                     
[3;1H                     tokLoc :: Token -> Loc
[4;1H                     tokLoc = fst
[5;1H                     
[6;1H                     tokStr :: Token -> String
[7;1H                     tokStr = snd
[8;1H                     
[9;1H                     type Parser a = [Token] -> [(a, [Token])]
[10;1H                     
[11;1H                     pLit :: String -> Parser String
[12;1H                     pLit s = pSat (s ==)
[13;1H                     
[14;1H                     pSat :: (String -> Bool) -> Parser String
[15;1H                     pSat p str = case str of
[16;1H                       (_, s) : toks
[17;1H                         | p s       -> [(s,toks)]
[18;1H                       _             -> []
[19;1H                     
[20;1H                     pVar :: Parser String
[21;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[22;1H                     
[23;1H                     keywords :: [String]
[24;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[25;1H                     
[26;1H                     pNum :: Parser Int
[27;1H                     pNum = read <$$> pSat (all isDigit)
[28;1H                     
[29;1H                     pAlt :: Parser a -> Parser a -> Parser a
[30;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[31;1H                     
[32;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[33;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[34;1H                     
[35;1H                     infixr 3 `pAlt`, `pAlt'`
[36;1H                     
[37;1H                     (<+) :: [a] -> [a] -> [a]
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     
[2;1H                     tokLoc :: Token -> Loc
[3;1H                     tokLoc = fst
[4;1H                     
[5;1H                     tokStr :: Token -> String
[6;1H                     tokStr = snd
[7;1H                     
[8;1H                     type Parser a = [Token] -> [(a, [Token])]
[9;1H                     
[10;1H                     pLit :: String -> Parser String
[11;1H                     pLit s = pSat (s ==)
[12;1H                     
[13;1H                     pSat :: (String -> Bool) -> Parser String
[14;1H                     pSat p str = case str of
[15;1H                       (_, s) : toks
[16;1H                         | p s       -> [(s,toks)]
[17;1H                       _             -> []
[18;1H                     
[19;1H                     pVar :: Parser String
[20;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[21;1H                     
[22;1H                     keywords :: [String]
[23;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[24;1H                     
[25;1H                     pNum :: Parser Int
[26;1H                     pNum = read <$$> pSat (all isDigit)
[27;1H                     
[28;1H                     pAlt :: Parser a -> Parser a -> Parser a
[29;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[30;1H                     
[31;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[32;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[33;1H                     
[34;1H                     infixr 3 `pAlt`, `pAlt'`
[35;1H                     
[36;1H                     (<+) :: [a] -> [a] -> [a]
[37;1H                     [] <+ ys = ys
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     tokLoc :: Token -> Loc
[2;1H                     tokLoc = fst
[3;1H                     
[4;1H                     tokStr :: Token -> String
[5;1H                     tokStr = snd
[6;1H                     
[7;1H                     type Parser a = [Token] -> [(a, [Token])]
[8;1H                     
[9;1H                     pLit :: String -> Parser String
[10;1H                     pLit s = pSat (s ==)
[11;1H                     
[12;1H                     pSat :: (String -> Bool) -> Parser String
[13;1H                     pSat p str = case str of
[14;1H                       (_, s) : toks
[15;1H                         | p s       -> [(s,toks)]
[16;1H                       _             -> []
[17;1H                     
[18;1H                     pVar :: Parser String
[19;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[20;1H                     
[21;1H                     keywords :: [String]
[22;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[23;1H                     
[24;1H                     pNum :: Parser Int
[25;1H                     pNum = read <$$> pSat (all isDigit)
[26;1H                     
[27;1H                     pAlt :: Parser a -> Parser a -> Parser a
[28;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[29;1H                     
[30;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[31;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[32;1H                     
[33;1H                     infixr 3 `pAlt`, `pAlt'`
[34;1H                     
[35;1H                     (<+) :: [a] -> [a] -> [a]
[36;1H                     [] <+ ys = ys
[37;1H                     xs <+ _  = xs
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     tokLoc = fst
[2;1H                     
[3;1H                     tokStr :: Token -> String
[4;1H                     tokStr = snd
[5;1H                     
[6;1H                     type Parser a = [Token] -> [(a, [Token])]
[7;1H                     
[8;1H                     pLit :: String -> Parser String
[9;1H                     pLit s = pSat (s ==)
[10;1H                     
[11;1H                     pSat :: (String -> Bool) -> Parser String
[12;1H                     pSat p str = case str of
[13;1H                       (_, s) : toks
[14;1H                         | p s       -> [(s,toks)]
[15;1H                       _             -> []
[16;1H                     
[17;1H                     pVar :: Parser String
[18;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[19;1H                     
[20;1H                     keywords :: [String]
[21;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[22;1H                     
[23;1H                     pNum :: Parser Int
[24;1H                     pNum = read <$$> pSat (all isDigit)
[25;1H                     
[26;1H                     pAlt :: Parser a -> Parser a -> Parser a
[27;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[28;1H                     
[29;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[30;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[31;1H                     
[32;1H                     infixr 3 `pAlt`, `pAlt'`
[33;1H                     
[34;1H                     (<+) :: [a] -> [a] -> [a]
[35;1H                     [] <+ ys = ys
[36;1H                     xs <+ _  = xs
[37;1H                     
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     
[2;1H                     tokStr :: Token -> String
[3;1H                     tokStr = snd
[4;1H                     
[5;1H                     type Parser a = [Token] -> [(a, [Token])]
[6;1H                     
[7;1H                     pLit :: String -> Parser String
[8;1H                     pLit s = pSat (s ==)
[9;1H                     
[10;1H                     pSat :: (String -> Bool) -> Parser String
[11;1H                     pSat p str = case str of
[12;1H                       (_, s) : toks
[13;1H                         | p s       -> [(s,toks)]
[14;1H                       _             -> []
[15;1H                     
[16;1H                     pVar :: Parser String
[17;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[18;1H                     
[19;1H                     keywords :: [String]
[20;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[21;1H                     
[22;1H                     pNum :: Parser Int
[23;1H                     pNum = read <$$> pSat (all isDigit)
[24;1H                     
[25;1H                     pAlt :: Parser a -> Parser a -> Parser a
[26;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[27;1H                     
[28;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[29;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[30;1H                     
[31;1H                     infixr 3 `pAlt`, `pAlt'`
[32;1H                     
[33;1H                     (<+) :: [a] -> [a] -> [a]
[34;1H                     [] <+ ys = ys
[35;1H                     xs <+ _  = xs
[36;1H                     
[37;1H                     infixr 5 <+
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     tokStr :: Token -> String
[2;1H                     tokStr = snd
[3;1H                     
[4;1H                     type Parser a = [Token] -> [(a, [Token])]
[5;1H                     
[6;1H                     pLit :: String -> Parser String
[7;1H                     pLit s = pSat (s ==)
[8;1H                     
[9;1H                     pSat :: (String -> Bool) -> Parser String
[10;1H                     pSat p str = case str of
[11;1H                       (_, s) : toks
[12;1H                         | p s       -> [(s,toks)]
[13;1H                       _             -> []
[14;1H                     
[15;1H                     pVar :: Parser String
[16;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[17;1H                     
[18;1H                     keywords :: [String]
[19;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[20;1H                     
[21;1H                     pNum :: Parser Int
[22;1H                     pNum = read <$$> pSat (all isDigit)
[23;1H                     
[24;1H                     pAlt :: Parser a -> Parser a -> Parser a
[25;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[26;1H                     
[27;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[28;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[29;1H                     
[30;1H                     infixr 3 `pAlt`, `pAlt'`
[31;1H                     
[32;1H                     (<+) :: [a] -> [a] -> [a]
[33;1H                     [] <+ ys = ys
[34;1H                     xs <+ _  = xs
[35;1H                     
[36;1H                     infixr 5 <+
[37;1H                     
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     tokStr = snd
[2;1H                     
[3;1H                     type Parser a = [Token] -> [(a, [Token])]
[4;1H                     
[5;1H                     pLit :: String -> Parser String
[6;1H                     pLit s = pSat (s ==)
[7;1H                     
[8;1H                     pSat :: (String -> Bool) -> Parser String
[9;1H                     pSat p str = case str of
[10;1H                       (_, s) : toks
[11;1H                         | p s       -> [(s,toks)]
[12;1H                       _             -> []
[13;1H                     
[14;1H                     pVar :: Parser String
[15;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[16;1H                     
[17;1H                     keywords :: [String]
[18;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[19;1H                     
[20;1H                     pNum :: Parser Int
[21;1H                     pNum = read <$$> pSat (all isDigit)
[22;1H                     
[23;1H                     pAlt :: Parser a -> Parser a -> Parser a
[24;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[25;1H                     
[26;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[27;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[28;1H                     
[29;1H                     infixr 3 `pAlt`, `pAlt'`
[30;1H                     
[31;1H                     (<+) :: [a] -> [a] -> [a]
[32;1H                     [] <+ ys = ys
[33;1H                     xs <+ _  = xs
[34;1H                     
[35;1H                     infixr 5 <+
[36;1H                     
[37;1H                     pEmpty :: a -> Parser a
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     
[2;1H                     type Parser a = [Token] -> [(a, [Token])]
[3;1H                     
[4;1H                     pLit :: String -> Parser String
[5;1H                     pLit s = pSat (s ==)
[6;1H                     
[7;1H                     pSat :: (String -> Bool) -> Parser String
[8;1H                     pSat p str = case str of
[9;1H                       (_, s) : toks
[10;1H                         | p s       -> [(s,toks)]
[11;1H                       _             -> []
[12;1H                     
[13;1H                     pVar :: Parser String
[14;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[15;1H                     
[16;1H                     keywords :: [String]
[17;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[18;1H                     
[19;1H                     pNum :: Parser Int
[20;1H                     pNum = read <$$> pSat (all isDigit)
[21;1H                     
[22;1H                     pAlt :: Parser a -> Parser a -> Parser a
[23;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[24;1H                     
[25;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[26;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[27;1H                     
[28;1H                     infixr 3 `pAlt`, `pAlt'`
[29;1H                     
[30;1H                     (<+) :: [a] -> [a] -> [a]
[31;1H                     [] <+ ys = ys
[32;1H                     xs <+ _  = xs
[33;1H                     
[34;1H                     infixr 5 <+
[35;1H                     
[36;1H                     pEmpty :: a -> Parser a
[37;1H                     pEmpty x toks = [(x, toks)]
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     type Parser a = [Token] -> [(a, [Token])]
[2;1H                     
[3;1H                     pLit :: String -> Parser String
[4;1H                     pLit s = pSat (s ==)
[5;1H                     
[6;1H                     pSat :: (String -> Bool) -> Parser String
[7;1H                     pSat p str = case str of
[8;1H                       (_, s) : toks
[9;1H                         | p s       -> [(s,toks)]
[10;1H                       _             -> []
[11;1H                     
[12;1H                     pVar :: Parser String
[13;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[14;1H                     
[15;1H                     keywords :: [String]
[16;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[17;1H                     
[18;1H                     pNum :: Parser Int
[19;1H                     pNum = read <$$> pSat (all isDigit)
[20;1H                     
[21;1H                     pAlt :: Parser a -> Parser a -> Parser a
[22;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[23;1H                     
[24;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[25;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[26;1H                     
[27;1H                     infixr 3 `pAlt`, `pAlt'`
[28;1H                     
[29;1H                     (<+) :: [a] -> [a] -> [a]
[30;1H                     [] <+ ys = ys
[31;1H                     xs <+ _  = xs
[32;1H                     
[33;1H                     infixr 5 <+
[34;1H                     
[35;1H                     pEmpty :: a -> Parser a
[36;1H                     pEmpty x toks = [(x, toks)]
[37;1H                     
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     
[2;1H                     pLit :: String -> Parser String
[3;1H                     pLit s = pSat (s ==)
[4;1H                     
[5;1H                     pSat :: (String -> Bool) -> Parser String
[6;1H                     pSat p str = case str of
[7;1H                       (_, s) : toks
[8;1H                         | p s       -> [(s,toks)]
[9;1H                       _             -> []
[10;1H                     
[11;1H                     pVar :: Parser String
[12;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[13;1H                     
[14;1H                     keywords :: [String]
[15;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[16;1H                     
[17;1H                     pNum :: Parser Int
[18;1H                     pNum = read <$$> pSat (all isDigit)
[19;1H                     
[20;1H                     pAlt :: Parser a -> Parser a -> Parser a
[21;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[22;1H                     
[23;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[24;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[25;1H                     
[26;1H                     infixr 3 `pAlt`, `pAlt'`
[27;1H                     
[28;1H                     (<+) :: [a] -> [a] -> [a]
[29;1H                     [] <+ ys = ys
[30;1H                     xs <+ _  = xs
[31;1H                     
[32;1H                     infixr 5 <+
[33;1H                     
[34;1H                     pEmpty :: a -> Parser a
[35;1H                     pEmpty x toks = [(x, toks)]
[36;1H                     
[37;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     pLit :: String -> Parser String
[2;1H                     pLit s = pSat (s ==)
[3;1H                     
[4;1H                     pSat :: (String -> Bool) -> Parser String
[5;1H                     pSat p str = case str of
[6;1H                       (_, s) : toks
[7;1H                         | p s       -> [(s,toks)]
[8;1H                       _             -> []
[9;1H                     
[10;1H                     pVar :: Parser String
[11;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[12;1H                     
[13;1H                     keywords :: [String]
[14;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[15;1H                     
[16;1H                     pNum :: Parser Int
[17;1H                     pNum = read <$$> pSat (all isDigit)
[18;1H                     
[19;1H                     pAlt :: Parser a -> Parser a -> Parser a
[20;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[21;1H                     
[22;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[23;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[24;1H                     
[25;1H                     infixr 3 `pAlt`, `pAlt'`
[26;1H                     
[27;1H                     (<+) :: [a] -> [a] -> [a]
[28;1H                     [] <+ ys = ys
[29;1H                     xs <+ _  = xs
[30;1H                     
[31;1H                     infixr 5 <+
[32;1H                     
[33;1H                     pEmpty :: a -> Parser a
[34;1H                     pEmpty x toks = [(x, toks)]
[35;1H                     
[36;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[37;1H                     pThen combine p1 p2 toks
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     pLit s = pSat (s ==)
[2;1H                     
[3;1H                     pSat :: (String -> Bool) -> Parser String
[4;1H                     pSat p str = case str of
[5;1H                       (_, s) : toks
[6;1H                         | p s       -> [(s,toks)]
[7;1H                       _             -> []
[8;1H                     
[9;1H                     pVar :: Parser String
[10;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[11;1H                     
[12;1H                     keywords :: [String]
[13;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[14;1H                     
[15;1H                     pNum :: Parser Int
[16;1H                     pNum = read <$$> pSat (all isDigit)
[17;1H                     
[18;1H                     pAlt :: Parser a -> Parser a -> Parser a
[19;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[20;1H                     
[21;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[22;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[23;1H                     
[24;1H                     infixr 3 `pAlt`, `pAlt'`
[25;1H                     
[26;1H                     (<+) :: [a] -> [a] -> [a]
[27;1H                     [] <+ ys = ys
[28;1H                     xs <+ _  = xs
[29;1H                     
[30;1H                     infixr 5 <+
[31;1H                     
[32;1H                     pEmpty :: a -> Parser a
[33;1H                     pEmpty x toks = [(x, toks)]
[34;1H                     
[35;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[36;1H                     pThen combine p1 p2 toks
[37;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     
[2;1H                     pSat :: (String -> Bool) -> Parser String
[3;1H                     pSat p str = case str of
[4;1H                       (_, s) : toks
[5;1H                         | p s       -> [(s,toks)]
[6;1H                       _             -> []
[7;1H                     
[8;1H                     pVar :: Parser String
[9;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[10;1H                     
[11;1H                     keywords :: [String]
[12;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[13;1H                     
[14;1H                     pNum :: Parser Int
[15;1H                     pNum = read <$$> pSat (all isDigit)
[16;1H                     
[17;1H                     pAlt :: Parser a -> Parser a -> Parser a
[18;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[19;1H                     
[20;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[21;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[22;1H                     
[23;1H                     infixr 3 `pAlt`, `pAlt'`
[24;1H                     
[25;1H                     (<+) :: [a] -> [a] -> [a]
[26;1H                     [] <+ ys = ys
[27;1H                     xs <+ _  = xs
[28;1H                     
[29;1H                     infixr 5 <+
[30;1H                     
[31;1H                     pEmpty :: a -> Parser a
[32;1H                     pEmpty x toks = [(x, toks)]
[33;1H                     
[34;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[35;1H                     pThen combine p1 p2 toks
[36;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[37;1H                                                  , (v2, toks2) <- p2 toks1 ]
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     pSat :: (String -> Bool) -> Parser String
[2;1H                     pSat p str = case str of
[3;1H                       (_, s) : toks
[4;1H                         | p s       -> [(s,toks)]
[5;1H                       _             -> []
[6;1H                     
[7;1H                     pVar :: Parser String
[8;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[9;1H                     
[10;1H                     keywords :: [String]
[11;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[12;1H                     
[13;1H                     pNum :: Parser Int
[14;1H                     pNum = read <$$> pSat (all isDigit)
[15;1H                     
[16;1H                     pAlt :: Parser a -> Parser a -> Parser a
[17;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[18;1H                     
[19;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[20;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[21;1H                     
[22;1H                     infixr 3 `pAlt`, `pAlt'`
[23;1H                     
[24;1H                     (<+) :: [a] -> [a] -> [a]
[25;1H                     [] <+ ys = ys
[26;1H                     xs <+ _  = xs
[27;1H                     
[28;1H                     infixr 5 <+
[29;1H                     
[30;1H                     pEmpty :: a -> Parser a
[31;1H                     pEmpty x toks = [(x, toks)]
[32;1H                     
[33;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[34;1H                     pThen combine p1 p2 toks
[35;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[36;1H                                                  , (v2, toks2) <- p2 toks1 ]
[37;1H                     
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     pSat p str = case str of
[2;1H                       (_, s) : toks
[3;1H                         | p s       -> [(s,toks)]
[4;1H                       _             -> []
[5;1H                     
[6;1H                     pVar :: Parser String
[7;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[8;1H                     
[9;1H                     keywords :: [String]
[10;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[11;1H                     
[12;1H                     pNum :: Parser Int
[13;1H                     pNum = read <$$> pSat (all isDigit)
[14;1H                     
[15;1H                     pAlt :: Parser a -> Parser a -> Parser a
[16;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[17;1H                     
[18;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[19;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[20;1H                     
[21;1H                     infixr 3 `pAlt`, `pAlt'`
[22;1H                     
[23;1H                     (<+) :: [a] -> [a] -> [a]
[24;1H                     [] <+ ys = ys
[25;1H                     xs <+ _  = xs
[26;1H                     
[27;1H                     infixr 5 <+
[28;1H                     
[29;1H                     pEmpty :: a -> Parser a
[30;1H                     pEmpty x toks = [(x, toks)]
[31;1H                     
[32;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[33;1H                     pThen combine p1 p2 toks
[34;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[35;1H                                                  , (v2, toks2) <- p2 toks1 ]
[36;1H                     
[37;1H                     pThen3 :: (a -> b -> c -> d) 
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                       (_, s) : toks
[2;1H                         | p s       -> [(s,toks)]
[3;1H                       _             -> []
[4;1H                     
[5;1H                     pVar :: Parser String
[6;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[7;1H                     
[8;1H                     keywords :: [String]
[9;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[10;1H                     
[11;1H                     pNum :: Parser Int
[12;1H                     pNum = read <$$> pSat (all isDigit)
[13;1H                     
[14;1H                     pAlt :: Parser a -> Parser a -> Parser a
[15;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[16;1H                     
[17;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[18;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[19;1H                     
[20;1H                     infixr 3 `pAlt`, `pAlt'`
[21;1H                     
[22;1H                     (<+) :: [a] -> [a] -> [a]
[23;1H                     [] <+ ys = ys
[24;1H                     xs <+ _  = xs
[25;1H                     
[26;1H                     infixr 5 <+
[27;1H                     
[28;1H                     pEmpty :: a -> Parser a
[29;1H                     pEmpty x toks = [(x, toks)]
[30;1H                     
[31;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[32;1H                     pThen combine p1 p2 toks
[33;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[34;1H                                                  , (v2, toks2) <- p2 toks1 ]
[35;1H                     
[36;1H                     pThen3 :: (a -> b -> c -> d) 
[37;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                         | p s       -> [(s,toks)]
[2;1H                       _             -> []
[3;1H                     
[4;1H                     pVar :: Parser String
[5;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[6;1H                     
[7;1H                     keywords :: [String]
[8;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[9;1H                     
[10;1H                     pNum :: Parser Int
[11;1H                     pNum = read <$$> pSat (all isDigit)
[12;1H                     
[13;1H                     pAlt :: Parser a -> Parser a -> Parser a
[14;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[15;1H                     
[16;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[17;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[18;1H                     
[19;1H                     infixr 3 `pAlt`, `pAlt'`
[20;1H                     
[21;1H                     (<+) :: [a] -> [a] -> [a]
[22;1H                     [] <+ ys = ys
[23;1H                     xs <+ _  = xs
[24;1H                     
[25;1H                     infixr 5 <+
[26;1H                     
[27;1H                     pEmpty :: a -> Parser a
[28;1H                     pEmpty x toks = [(x, toks)]
[29;1H                     
[30;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[31;1H                     pThen combine p1 p2 toks
[32;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[33;1H                                                  , (v2, toks2) <- p2 toks1 ]
[34;1H                     
[35;1H                     pThen3 :: (a -> b -> c -> d) 
[36;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[37;1H                     pThen3 combine p1 p2 p3 toks
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                       _             -> []
[2;1H                     
[3;1H                     pVar :: Parser String
[4;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[5;1H                     
[6;1H                     keywords :: [String]
[7;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[8;1H                     
[9;1H                     pNum :: Parser Int
[10;1H                     pNum = read <$$> pSat (all isDigit)
[11;1H                     
[12;1H                     pAlt :: Parser a -> Parser a -> Parser a
[13;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[14;1H                     
[15;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[16;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[17;1H                     
[18;1H                     infixr 3 `pAlt`, `pAlt'`
[19;1H                     
[20;1H                     (<+) :: [a] -> [a] -> [a]
[21;1H                     [] <+ ys = ys
[22;1H                     xs <+ _  = xs
[23;1H                     
[24;1H                     infixr 5 <+
[25;1H                     
[26;1H                     pEmpty :: a -> Parser a
[27;1H                     pEmpty x toks = [(x, toks)]
[28;1H                     
[29;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[30;1H                     pThen combine p1 p2 toks
[31;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[32;1H                                                  , (v2, toks2) <- p2 toks1 ]
[33;1H                     
[34;1H                     pThen3 :: (a -> b -> c -> d) 
[35;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[36;1H                     pThen3 combine p1 p2 p3 toks
[37;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     
[2;1H                     pVar :: Parser String
[3;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[4;1H                     
[5;1H                     keywords :: [String]
[6;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[7;1H                     
[8;1H                     pNum :: Parser Int
[9;1H                     pNum = read <$$> pSat (all isDigit)
[10;1H                     
[11;1H                     pAlt :: Parser a -> Parser a -> Parser a
[12;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[13;1H                     
[14;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[15;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[16;1H                     
[17;1H                     infixr 3 `pAlt`, `pAlt'`
[18;1H                     
[19;1H                     (<+) :: [a] -> [a] -> [a]
[20;1H                     [] <+ ys = ys
[21;1H                     xs <+ _  = xs
[22;1H                     
[23;1H                     infixr 5 <+
[24;1H                     
[25;1H                     pEmpty :: a -> Parser a
[26;1H                     pEmpty x toks = [(x, toks)]
[27;1H                     
[28;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[29;1H                     pThen combine p1 p2 toks
[30;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[31;1H                                                  , (v2, toks2) <- p2 toks1 ]
[32;1H                     
[33;1H                     pThen3 :: (a -> b -> c -> d) 
[34;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[35;1H                     pThen3 combine p1 p2 p3 toks
[36;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[37;1H                                                     , (v2, toks2) <- p2 toks1
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     pVar :: Parser String
[2;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[3;1H                     
[4;1H                     keywords :: [String]
[5;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[6;1H                     
[7;1H                     pNum :: Parser Int
[8;1H                     pNum = read <$$> pSat (all isDigit)
[9;1H                     
[10;1H                     pAlt :: Parser a -> Parser a -> Parser a
[11;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[12;1H                     
[13;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[14;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[15;1H                     
[16;1H                     infixr 3 `pAlt`, `pAlt'`
[17;1H                     
[18;1H                     (<+) :: [a] -> [a] -> [a]
[19;1H                     [] <+ ys = ys
[20;1H                     xs <+ _  = xs
[21;1H                     
[22;1H                     infixr 5 <+
[23;1H                     
[24;1H                     pEmpty :: a -> Parser a
[25;1H                     pEmpty x toks = [(x, toks)]
[26;1H                     
[27;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[28;1H                     pThen combine p1 p2 toks
[29;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[30;1H                                                  , (v2, toks2) <- p2 toks1 ]
[31;1H                     
[32;1H                     pThen3 :: (a -> b -> c -> d) 
[33;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[34;1H                     pThen3 combine p1 p2 p3 toks
[35;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[36;1H                                                     , (v2, toks2) <- p2 toks1
[37;1H                                                     , (v3, toks3) <- p3 toks2 ]
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     pVar = pSat ((&&) . isAlpha . head <*> (`notElem` keywords))
[2;1H                     
[3;1H                     keywords :: [String]
[4;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[5;1H                     
[6;1H                     pNum :: Parser Int
[7;1H                     pNum = read <$$> pSat (all isDigit)
[8;1H                     
[9;1H                     pAlt :: Parser a -> Parser a -> Parser a
[10;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[11;1H                     
[12;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[13;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[14;1H                     
[15;1H                     infixr 3 `pAlt`, `pAlt'`
[16;1H                     
[17;1H                     (<+) :: [a] -> [a] -> [a]
[18;1H                     [] <+ ys = ys
[19;1H                     xs <+ _  = xs
[20;1H                     
[21;1H                     infixr 5 <+
[22;1H                     
[23;1H                     pEmpty :: a -> Parser a
[24;1H                     pEmpty x toks = [(x, toks)]
[25;1H                     
[26;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[27;1H                     pThen combine p1 p2 toks
[28;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[29;1H                                                  , (v2, toks2) <- p2 toks1 ]
[30;1H                     
[31;1H                     pThen3 :: (a -> b -> c -> d) 
[32;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[33;1H                     pThen3 combine p1 p2 p3 toks
[34;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[35;1H                                                     , (v2, toks2) <- p2 toks1
[36;1H                                                     , (v3, toks3) <- p3 toks2 ]
[37;1H                     
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     
[2;1H                     keywords :: [String]
[3;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[4;1H                     
[5;1H                     pNum :: Parser Int
[6;1H                     pNum = read <$$> pSat (all isDigit)
[7;1H                     
[8;1H                     pAlt :: Parser a -> Parser a -> Parser a
[9;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[10;1H                     
[11;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[12;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[13;1H                     
[14;1H                     infixr 3 `pAlt`, `pAlt'`
[15;1H                     
[16;1H                     (<+) :: [a] -> [a] -> [a]
[17;1H                     [] <+ ys = ys
[18;1H                     xs <+ _  = xs
[19;1H                     
[20;1H                     infixr 5 <+
[21;1H                     
[22;1H                     pEmpty :: a -> Parser a
[23;1H                     pEmpty x toks = [(x, toks)]
[24;1H                     
[25;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[26;1H                     pThen combine p1 p2 toks
[27;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[28;1H                                                  , (v2, toks2) <- p2 toks1 ]
[29;1H                     
[30;1H                     pThen3 :: (a -> b -> c -> d) 
[31;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[32;1H                     pThen3 combine p1 p2 p3 toks
[33;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[34;1H                                                     , (v2, toks2) <- p2 toks1
[35;1H                                                     , (v3, toks3) <- p3 toks2 ]
[36;1H                     
[37;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     keywords :: [String]
[2;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[3;1H                     
[4;1H                     pNum :: Parser Int
[5;1H                     pNum = read <$$> pSat (all isDigit)
[6;1H                     
[7;1H                     pAlt :: Parser a -> Parser a -> Parser a
[8;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[9;1H                     
[10;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[11;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[12;1H                     
[13;1H                     infixr 3 `pAlt`, `pAlt'`
[14;1H                     
[15;1H                     (<+) :: [a] -> [a] -> [a]
[16;1H                     [] <+ ys = ys
[17;1H                     xs <+ _  = xs
[18;1H                     
[19;1H                     infixr 5 <+
[20;1H                     
[21;1H                     pEmpty :: a -> Parser a
[22;1H                     pEmpty x toks = [(x, toks)]
[23;1H                     
[24;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[25;1H                     pThen combine p1 p2 toks
[26;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[27;1H                                                  , (v2, toks2) <- p2 toks1 ]
[28;1H                     
[29;1H                     pThen3 :: (a -> b -> c -> d) 
[30;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[31;1H                     pThen3 combine p1 p2 p3 toks
[32;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[33;1H                                                     , (v2, toks2) <- p2 toks1
[34;1H                                                     , (v3, toks3) <- p3 toks2 ]
[35;1H                     
[36;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[37;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     keywords = ["let", "letrec", "case", "in", "of", "Pack"]
[2;1H                     
[3;1H                     pNum :: Parser Int
[4;1H                     pNum = read <$$> pSat (all isDigit)
[5;1H                     
[6;1H                     pAlt :: Parser a -> Parser a -> Parser a
[7;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[8;1H                     
[9;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[10;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[11;1H                     
[12;1H                     infixr 3 `pAlt`, `pAlt'`
[13;1H                     
[14;1H                     (<+) :: [a] -> [a] -> [a]
[15;1H                     [] <+ ys = ys
[16;1H                     xs <+ _  = xs
[17;1H                     
[18;1H                     infixr 5 <+
[19;1H                     
[20;1H                     pEmpty :: a -> Parser a
[21;1H                     pEmpty x toks = [(x, toks)]
[22;1H                     
[23;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[24;1H                     pThen combine p1 p2 toks
[25;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[26;1H                                                  , (v2, toks2) <- p2 toks1 ]
[27;1H                     
[28;1H                     pThen3 :: (a -> b -> c -> d) 
[29;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[30;1H                     pThen3 combine p1 p2 p3 toks
[31;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[32;1H                                                     , (v2, toks2) <- p2 toks1
[33;1H                                                     , (v3, toks3) <- p3 toks2 ]
[34;1H                     
[35;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[36;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[37;1H                     pThen4 combine p1 p2 p3 p4 toks
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     
[2;1H                     pNum :: Parser Int
[3;1H                     pNum = read <$$> pSat (all isDigit)
[4;1H                     
[5;1H                     pAlt :: Parser a -> Parser a -> Parser a
[6;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[7;1H                     
[8;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[9;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[10;1H                     
[11;1H                     infixr 3 `pAlt`, `pAlt'`
[12;1H                     
[13;1H                     (<+) :: [a] -> [a] -> [a]
[14;1H                     [] <+ ys = ys
[15;1H                     xs <+ _  = xs
[16;1H                     
[17;1H                     infixr 5 <+
[18;1H                     
[19;1H                     pEmpty :: a -> Parser a
[20;1H                     pEmpty x toks = [(x, toks)]
[21;1H                     
[22;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[23;1H                     pThen combine p1 p2 toks
[24;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[25;1H                                                  , (v2, toks2) <- p2 toks1 ]
[26;1H                     
[27;1H                     pThen3 :: (a -> b -> c -> d) 
[28;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[29;1H                     pThen3 combine p1 p2 p3 toks
[30;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[31;1H                                                     , (v2, toks2) <- p2 toks1
[32;1H                                                     , (v3, toks3) <- p3 toks2 ]
[33;1H                     
[34;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[35;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[36;1H                     pThen4 combine p1 p2 p3 p4 toks
[37;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     pNum :: Parser Int
[2;1H                     pNum = read <$$> pSat (all isDigit)
[3;1H                     
[4;1H                     pAlt :: Parser a -> Parser a -> Parser a
[5;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[6;1H                     
[7;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[8;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[9;1H                     
[10;1H                     infixr 3 `pAlt`, `pAlt'`
[11;1H                     
[12;1H                     (<+) :: [a] -> [a] -> [a]
[13;1H                     [] <+ ys = ys
[14;1H                     xs <+ _  = xs
[15;1H                     
[16;1H                     infixr 5 <+
[17;1H                     
[18;1H                     pEmpty :: a -> Parser a
[19;1H                     pEmpty x toks = [(x, toks)]
[20;1H                     
[21;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[22;1H                     pThen combine p1 p2 toks
[23;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[24;1H                                                  , (v2, toks2) <- p2 toks1 ]
[25;1H                     
[26;1H                     pThen3 :: (a -> b -> c -> d) 
[27;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[28;1H                     pThen3 combine p1 p2 p3 toks
[29;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[30;1H                                                     , (v2, toks2) <- p2 toks1
[31;1H                                                     , (v3, toks3) <- p3 toks2 ]
[32;1H                     
[33;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[34;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[35;1H                     pThen4 combine p1 p2 p3 p4 toks
[36;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[37;1H                                                        , (v2, toks2) <- p2 toks1
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     pNum = read <$$> pSat (all isDigit)
[2;1H                     
[3;1H                     pAlt :: Parser a -> Parser a -> Parser a
[4;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[5;1H                     
[6;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[7;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[8;1H                     
[9;1H                     infixr 3 `pAlt`, `pAlt'`
[10;1H                     
[11;1H                     (<+) :: [a] -> [a] -> [a]
[12;1H                     [] <+ ys = ys
[13;1H                     xs <+ _  = xs
[14;1H                     
[15;1H                     infixr 5 <+
[16;1H                     
[17;1H                     pEmpty :: a -> Parser a
[18;1H                     pEmpty x toks = [(x, toks)]
[19;1H                     
[20;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[21;1H                     pThen combine p1 p2 toks
[22;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[23;1H                                                  , (v2, toks2) <- p2 toks1 ]
[24;1H                     
[25;1H                     pThen3 :: (a -> b -> c -> d) 
[26;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[27;1H                     pThen3 combine p1 p2 p3 toks
[28;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[29;1H                                                     , (v2, toks2) <- p2 toks1
[30;1H                                                     , (v3, toks3) <- p3 toks2 ]
[31;1H                     
[32;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[33;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[34;1H                     pThen4 combine p1 p2 p3 p4 toks
[35;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[36;1H                                                        , (v2, toks2) <- p2 toks1
[37;1H                                                        , (v3, toks3) <- p3 toks2
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     
[2;1H                     pAlt :: Parser a -> Parser a -> Parser a
[3;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[4;1H                     
[5;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[6;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[7;1H                     
[8;1H                     infixr 3 `pAlt`, `pAlt'`
[9;1H                     
[10;1H                     (<+) :: [a] -> [a] -> [a]
[11;1H                     [] <+ ys = ys
[12;1H                     xs <+ _  = xs
[13;1H                     
[14;1H                     infixr 5 <+
[15;1H                     
[16;1H                     pEmpty :: a -> Parser a
[17;1H                     pEmpty x toks = [(x, toks)]
[18;1H                     
[19;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[20;1H                     pThen combine p1 p2 toks
[21;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[22;1H                                                  , (v2, toks2) <- p2 toks1 ]
[23;1H                     
[24;1H                     pThen3 :: (a -> b -> c -> d) 
[25;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[26;1H                     pThen3 combine p1 p2 p3 toks
[27;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[28;1H                                                     , (v2, toks2) <- p2 toks1
[29;1H                                                     , (v3, toks3) <- p3 toks2 ]
[30;1H                     
[31;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[32;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[33;1H                     pThen4 combine p1 p2 p3 p4 toks
[34;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[35;1H                                                        , (v2, toks2) <- p2 toks1
[36;1H                                                        , (v3, toks3) <- p3 toks2
[37;1H                                                        , (v4, toks4) <- p4 toks3 ]
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     pAlt :: Parser a -> Parser a -> Parser a
[2;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[3;1H                     
[4;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[5;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[6;1H                     
[7;1H                     infixr 3 `pAlt`, `pAlt'`
[8;1H                     
[9;1H                     (<+) :: [a] -> [a] -> [a]
[10;1H                     [] <+ ys = ys
[11;1H                     xs <+ _  = xs
[12;1H                     
[13;1H                     infixr 5 <+
[14;1H                     
[15;1H                     pEmpty :: a -> Parser a
[16;1H                     pEmpty x toks = [(x, toks)]
[17;1H                     
[18;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[19;1H                     pThen combine p1 p2 toks
[20;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[21;1H                                                  , (v2, toks2) <- p2 toks1 ]
[22;1H                     
[23;1H                     pThen3 :: (a -> b -> c -> d) 
[24;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[25;1H                     pThen3 combine p1 p2 p3 toks
[26;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[27;1H                                                     , (v2, toks2) <- p2 toks1
[28;1H                                                     , (v3, toks3) <- p3 toks2 ]
[29;1H                     
[30;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[31;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[32;1H                     pThen4 combine p1 p2 p3 p4 toks
[33;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[34;1H                                                        , (v2, toks2) <- p2 toks1
[35;1H                                                        , (v3, toks3) <- p3 toks2
[36;1H                                                        , (v4, toks4) <- p4 toks3 ]
[37;1H                     
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     pAlt p1 p2 toks = p1 toks ++ p2 toks
[2;1H                     
[3;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[4;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[5;1H                     
[6;1H                     infixr 3 `pAlt`, `pAlt'`
[7;1H                     
[8;1H                     (<+) :: [a] -> [a] -> [a]
[9;1H                     [] <+ ys = ys
[10;1H                     xs <+ _  = xs
[11;1H                     
[12;1H                     infixr 5 <+
[13;1H                     
[14;1H                     pEmpty :: a -> Parser a
[15;1H                     pEmpty x toks = [(x, toks)]
[16;1H                     
[17;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[18;1H                     pThen combine p1 p2 toks
[19;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[20;1H                                                  , (v2, toks2) <- p2 toks1 ]
[21;1H                     
[22;1H                     pThen3 :: (a -> b -> c -> d) 
[23;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[24;1H                     pThen3 combine p1 p2 p3 toks
[25;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[26;1H                                                     , (v2, toks2) <- p2 toks1
[27;1H                                                     , (v3, toks3) <- p3 toks2 ]
[28;1H                     
[29;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[30;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[31;1H                     pThen4 combine p1 p2 p3 p4 toks
[32;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[33;1H                                                        , (v2, toks2) <- p2 toks1
[34;1H                                                        , (v3, toks3) <- p3 toks2
[35;1H                                                        , (v4, toks4) <- p4 toks3 ]
[36;1H                     
[37;1H                     pZeroOrMore :: Parser a -> Parser [a]
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     
[2;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[3;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[4;1H                     
[5;1H                     infixr 3 `pAlt`, `pAlt'`
[6;1H                     
[7;1H                     (<+) :: [a] -> [a] -> [a]
[8;1H                     [] <+ ys = ys
[9;1H                     xs <+ _  = xs
[10;1H                     
[11;1H                     infixr 5 <+
[12;1H                     
[13;1H                     pEmpty :: a -> Parser a
[14;1H                     pEmpty x toks = [(x, toks)]
[15;1H                     
[16;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[17;1H                     pThen combine p1 p2 toks
[18;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[19;1H                                                  , (v2, toks2) <- p2 toks1 ]
[20;1H                     
[21;1H                     pThen3 :: (a -> b -> c -> d) 
[22;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[23;1H                     pThen3 combine p1 p2 p3 toks
[24;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[25;1H                                                     , (v2, toks2) <- p2 toks1
[26;1H                                                     , (v3, toks3) <- p3 toks2 ]
[27;1H                     
[28;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[29;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[30;1H                     pThen4 combine p1 p2 p3 p4 toks
[31;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[32;1H                                                        , (v2, toks2) <- p2 toks1
[33;1H                                                        , (v3, toks3) <- p3 toks2
[34;1H                                                        , (v4, toks4) <- p4 toks3 ]
[35;1H                     
[36;1H                     pZeroOrMore :: Parser a -> Parser [a]
[37;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     pAlt' :: Parser a -> Parser a -> Parser a
[2;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[3;1H                     
[4;1H                     infixr 3 `pAlt`, `pAlt'`
[5;1H                     
[6;1H                     (<+) :: [a] -> [a] -> [a]
[7;1H                     [] <+ ys = ys
[8;1H                     xs <+ _  = xs
[9;1H                     
[10;1H                     infixr 5 <+
[11;1H                     
[12;1H                     pEmpty :: a -> Parser a
[13;1H                     pEmpty x toks = [(x, toks)]
[14;1H                     
[15;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[16;1H                     pThen combine p1 p2 toks
[17;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[18;1H                                                  , (v2, toks2) <- p2 toks1 ]
[19;1H                     
[20;1H                     pThen3 :: (a -> b -> c -> d) 
[21;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[22;1H                     pThen3 combine p1 p2 p3 toks
[23;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[24;1H                                                     , (v2, toks2) <- p2 toks1
[25;1H                                                     , (v3, toks3) <- p3 toks2 ]
[26;1H                     
[27;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[28;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[29;1H                     pThen4 combine p1 p2 p3 p4 toks
[30;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[31;1H                                                        , (v2, toks2) <- p2 toks1
[32;1H                                                        , (v3, toks3) <- p3 toks2
[33;1H                                                        , (v4, toks4) <- p4 toks3 ]
[34;1H                     
[35;1H                     pZeroOrMore :: Parser a -> Parser [a]
[36;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[37;1H                     
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     pAlt' p1 p2 toks = p1 toks <+ p2 toks
[2;1H                     
[3;1H                     infixr 3 `pAlt`, `pAlt'`
[4;1H                     
[5;1H                     (<+) :: [a] -> [a] -> [a]
[6;1H                     [] <+ ys = ys
[7;1H                     xs <+ _  = xs
[8;1H                     
[9;1H                     infixr 5 <+
[10;1H                     
[11;1H                     pEmpty :: a -> Parser a
[12;1H                     pEmpty x toks = [(x, toks)]
[13;1H                     
[14;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[15;1H                     pThen combine p1 p2 toks
[16;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[17;1H                                                  , (v2, toks2) <- p2 toks1 ]
[18;1H                     
[19;1H                     pThen3 :: (a -> b -> c -> d) 
[20;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[21;1H                     pThen3 combine p1 p2 p3 toks
[22;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[23;1H                                                     , (v2, toks2) <- p2 toks1
[24;1H                                                     , (v3, toks3) <- p3 toks2 ]
[25;1H                     
[26;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[27;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[28;1H                     pThen4 combine p1 p2 p3 p4 toks
[29;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[30;1H                                                        , (v2, toks2) <- p2 toks1
[31;1H                                                        , (v3, toks3) <- p3 toks2
[32;1H                                                        , (v4, toks4) <- p4 toks3 ]
[33;1H                     
[34;1H                     pZeroOrMore :: Parser a -> Parser [a]
[35;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[36;1H                     
[37;1H                     pOneOrMore :: Parser a -> Parser [a]
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     
[2;1H                     infixr 3 `pAlt`, `pAlt'`
[3;1H                     
[4;1H                     (<+) :: [a] -> [a] -> [a]
[5;1H                     [] <+ ys = ys
[6;1H                     xs <+ _  = xs
[7;1H                     
[8;1H                     infixr 5 <+
[9;1H                     
[10;1H                     pEmpty :: a -> Parser a
[11;1H                     pEmpty x toks = [(x, toks)]
[12;1H                     
[13;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[14;1H                     pThen combine p1 p2 toks
[15;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[16;1H                                                  , (v2, toks2) <- p2 toks1 ]
[17;1H                     
[18;1H                     pThen3 :: (a -> b -> c -> d) 
[19;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[20;1H                     pThen3 combine p1 p2 p3 toks
[21;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[22;1H                                                     , (v2, toks2) <- p2 toks1
[23;1H                                                     , (v3, toks3) <- p3 toks2 ]
[24;1H                     
[25;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[26;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[27;1H                     pThen4 combine p1 p2 p3 p4 toks
[28;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[29;1H                                                        , (v2, toks2) <- p2 toks1
[30;1H                                                        , (v3, toks3) <- p3 toks2
[31;1H                                                        , (v4, toks4) <- p4 toks3 ]
[32;1H                     
[33;1H                     pZeroOrMore :: Parser a -> Parser [a]
[34;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[35;1H                     
[36;1H                     pOneOrMore :: Parser a -> Parser [a]
[37;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     infixr 3 `pAlt`, `pAlt'`
[2;1H                     
[3;1H                     (<+) :: [a] -> [a] -> [a]
[4;1H                     [] <+ ys = ys
[5;1H                     xs <+ _  = xs
[6;1H                     
[7;1H                     infixr 5 <+
[8;1H                     
[9;1H                     pEmpty :: a -> Parser a
[10;1H                     pEmpty x toks = [(x, toks)]
[11;1H                     
[12;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[13;1H                     pThen combine p1 p2 toks
[14;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[15;1H                                                  , (v2, toks2) <- p2 toks1 ]
[16;1H                     
[17;1H                     pThen3 :: (a -> b -> c -> d) 
[18;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[19;1H                     pThen3 combine p1 p2 p3 toks
[20;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[21;1H                                                     , (v2, toks2) <- p2 toks1
[22;1H                                                     , (v3, toks3) <- p3 toks2 ]
[23;1H                     
[24;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[25;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[26;1H                     pThen4 combine p1 p2 p3 p4 toks
[27;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[28;1H                                                        , (v2, toks2) <- p2 toks1
[29;1H                                                        , (v3, toks3) <- p3 toks2
[30;1H                                                        , (v4, toks4) <- p4 toks3 ]
[31;1H                     
[32;1H                     pZeroOrMore :: Parser a -> Parser [a]
[33;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[34;1H                     
[35;1H                     pOneOrMore :: Parser a -> Parser [a]
[36;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[37;1H                     
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     
[2;1H                     (<+) :: [a] -> [a] -> [a]
[3;1H                     [] <+ ys = ys
[4;1H                     xs <+ _  = xs
[5;1H                     
[6;1H                     infixr 5 <+
[7;1H                     
[8;1H                     pEmpty :: a -> Parser a
[9;1H                     pEmpty x toks = [(x, toks)]
[10;1H                     
[11;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[12;1H                     pThen combine p1 p2 toks
[13;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[14;1H                                                  , (v2, toks2) <- p2 toks1 ]
[15;1H                     
[16;1H                     pThen3 :: (a -> b -> c -> d) 
[17;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[18;1H                     pThen3 combine p1 p2 p3 toks
[19;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[20;1H                                                     , (v2, toks2) <- p2 toks1
[21;1H                                                     , (v3, toks3) <- p3 toks2 ]
[22;1H                     
[23;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[24;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[25;1H                     pThen4 combine p1 p2 p3 p4 toks
[26;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[27;1H                                                        , (v2, toks2) <- p2 toks1
[28;1H                                                        , (v3, toks3) <- p3 toks2
[29;1H                                                        , (v4, toks4) <- p4 toks3 ]
[30;1H                     
[31;1H                     pZeroOrMore :: Parser a -> Parser [a]
[32;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[33;1H                     
[34;1H                     pOneOrMore :: Parser a -> Parser [a]
[35;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[36;1H                     
[37;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     (<+) :: [a] -> [a] -> [a]
[2;1H                     [] <+ ys = ys
[3;1H                     xs <+ _  = xs
[4;1H                     
[5;1H                     infixr 5 <+
[6;1H                     
[7;1H                     pEmpty :: a -> Parser a
[8;1H                     pEmpty x toks = [(x, toks)]
[9;1H                     
[10;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[11;1H                     pThen combine p1 p2 toks
[12;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[13;1H                                                  , (v2, toks2) <- p2 toks1 ]
[14;1H                     
[15;1H                     pThen3 :: (a -> b -> c -> d) 
[16;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[17;1H                     pThen3 combine p1 p2 p3 toks
[18;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[19;1H                                                     , (v2, toks2) <- p2 toks1
[20;1H                                                     , (v3, toks3) <- p3 toks2 ]
[21;1H                     
[22;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[23;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[24;1H                     pThen4 combine p1 p2 p3 p4 toks
[25;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[26;1H                                                        , (v2, toks2) <- p2 toks1
[27;1H                                                        , (v3, toks3) <- p3 toks2
[28;1H                                                        , (v4, toks4) <- p4 toks3 ]
[29;1H                     
[30;1H                     pZeroOrMore :: Parser a -> Parser [a]
[31;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[32;1H                     
[33;1H                     pOneOrMore :: Parser a -> Parser [a]
[34;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[35;1H                     
[36;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[37;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     [] <+ ys = ys
[2;1H                     xs <+ _  = xs
[3;1H                     
[4;1H                     infixr 5 <+
[5;1H                     
[6;1H                     pEmpty :: a -> Parser a
[7;1H                     pEmpty x toks = [(x, toks)]
[8;1H                     
[9;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[10;1H                     pThen combine p1 p2 toks
[11;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[12;1H                                                  , (v2, toks2) <- p2 toks1 ]
[13;1H                     
[14;1H                     pThen3 :: (a -> b -> c -> d) 
[15;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[16;1H                     pThen3 combine p1 p2 p3 toks
[17;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[18;1H                                                     , (v2, toks2) <- p2 toks1
[19;1H                                                     , (v3, toks3) <- p3 toks2 ]
[20;1H                     
[21;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[22;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[23;1H                     pThen4 combine p1 p2 p3 p4 toks
[24;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[25;1H                                                        , (v2, toks2) <- p2 toks1
[26;1H                                                        , (v3, toks3) <- p3 toks2
[27;1H                                                        , (v4, toks4) <- p4 toks3 ]
[28;1H                     
[29;1H                     pZeroOrMore :: Parser a -> Parser [a]
[30;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[31;1H                     
[32;1H                     pOneOrMore :: Parser a -> Parser [a]
[33;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[34;1H                     
[35;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[36;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[37;1H                     
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     xs <+ _  = xs
[2;1H                     
[3;1H                     infixr 5 <+
[4;1H                     
[5;1H                     pEmpty :: a -> Parser a
[6;1H                     pEmpty x toks = [(x, toks)]
[7;1H                     
[8;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[9;1H                     pThen combine p1 p2 toks
[10;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[11;1H                                                  , (v2, toks2) <- p2 toks1 ]
[12;1H                     
[13;1H                     pThen3 :: (a -> b -> c -> d) 
[14;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[15;1H                     pThen3 combine p1 p2 p3 toks
[16;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[17;1H                                                     , (v2, toks2) <- p2 toks1
[18;1H                                                     , (v3, toks3) <- p3 toks2 ]
[19;1H                     
[20;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[21;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[22;1H                     pThen4 combine p1 p2 p3 p4 toks
[23;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[24;1H                                                        , (v2, toks2) <- p2 toks1
[25;1H                                                        , (v3, toks3) <- p3 toks2
[26;1H                                                        , (v4, toks4) <- p4 toks3 ]
[27;1H                     
[28;1H                     pZeroOrMore :: Parser a -> Parser [a]
[29;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[30;1H                     
[31;1H                     pOneOrMore :: Parser a -> Parser [a]
[32;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[33;1H                     
[34;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[35;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[36;1H                     
[37;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     
[2;1H                     infixr 5 <+
[3;1H                     
[4;1H                     pEmpty :: a -> Parser a
[5;1H                     pEmpty x toks = [(x, toks)]
[6;1H                     
[7;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[8;1H                     pThen combine p1 p2 toks
[9;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[10;1H                                                  , (v2, toks2) <- p2 toks1 ]
[11;1H                     
[12;1H                     pThen3 :: (a -> b -> c -> d) 
[13;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[14;1H                     pThen3 combine p1 p2 p3 toks
[15;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[16;1H                                                     , (v2, toks2) <- p2 toks1
[17;1H                                                     , (v3, toks3) <- p3 toks2 ]
[18;1H                     
[19;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[20;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[21;1H                     pThen4 combine p1 p2 p3 p4 toks
[22;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[23;1H                                                        , (v2, toks2) <- p2 toks1
[24;1H                                                        , (v3, toks3) <- p3 toks2
[25;1H                                                        , (v4, toks4) <- p4 toks3 ]
[26;1H                     
[27;1H                     pZeroOrMore :: Parser a -> Parser [a]
[28;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[29;1H                     
[30;1H                     pOneOrMore :: Parser a -> Parser [a]
[31;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[32;1H                     
[33;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[34;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[35;1H                     
[36;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[37;1H                     (<$$>) = flip pApply
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     infixr 5 <+
[2;1H                     
[3;1H                     pEmpty :: a -> Parser a
[4;1H                     pEmpty x toks = [(x, toks)]
[5;1H                     
[6;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[7;1H                     pThen combine p1 p2 toks
[8;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[9;1H                                                  , (v2, toks2) <- p2 toks1 ]
[10;1H                     
[11;1H                     pThen3 :: (a -> b -> c -> d) 
[12;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[13;1H                     pThen3 combine p1 p2 p3 toks
[14;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[15;1H                                                     , (v2, toks2) <- p2 toks1
[16;1H                                                     , (v3, toks3) <- p3 toks2 ]
[17;1H                     
[18;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[19;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[20;1H                     pThen4 combine p1 p2 p3 p4 toks
[21;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[22;1H                                                        , (v2, toks2) <- p2 toks1
[23;1H                                                        , (v3, toks3) <- p3 toks2
[24;1H                                                        , (v4, toks4) <- p4 toks3 ]
[25;1H                     
[26;1H                     pZeroOrMore :: Parser a -> Parser [a]
[27;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[28;1H                     
[29;1H                     pOneOrMore :: Parser a -> Parser [a]
[30;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[31;1H                     
[32;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[33;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[34;1H                     
[35;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[36;1H                     (<$$>) = flip pApply
[37;1H                     
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     
[2;1H                     pEmpty :: a -> Parser a
[3;1H                     pEmpty x toks = [(x, toks)]
[4;1H                     
[5;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[6;1H                     pThen combine p1 p2 toks
[7;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[8;1H                                                  , (v2, toks2) <- p2 toks1 ]
[9;1H                     
[10;1H                     pThen3 :: (a -> b -> c -> d) 
[11;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[12;1H                     pThen3 combine p1 p2 p3 toks
[13;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[14;1H                                                     , (v2, toks2) <- p2 toks1
[15;1H                                                     , (v3, toks3) <- p3 toks2 ]
[16;1H                     
[17;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[18;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[19;1H                     pThen4 combine p1 p2 p3 p4 toks
[20;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[21;1H                                                        , (v2, toks2) <- p2 toks1
[22;1H                                                        , (v3, toks3) <- p3 toks2
[23;1H                                                        , (v4, toks4) <- p4 toks3 ]
[24;1H                     
[25;1H                     pZeroOrMore :: Parser a -> Parser [a]
[26;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[27;1H                     
[28;1H                     pOneOrMore :: Parser a -> Parser [a]
[29;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[30;1H                     
[31;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[32;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[33;1H                     
[34;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[35;1H                     (<$$>) = flip pApply
[36;1H                     
[37;1H                     (<$$) :: a -> Parser b -> Parser a
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     pEmpty :: a -> Parser a
[2;1H                     pEmpty x toks = [(x, toks)]
[3;1H                     
[4;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[5;1H                     pThen combine p1 p2 toks
[6;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[7;1H                                                  , (v2, toks2) <- p2 toks1 ]
[8;1H                     
[9;1H                     pThen3 :: (a -> b -> c -> d) 
[10;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[11;1H                     pThen3 combine p1 p2 p3 toks
[12;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[13;1H                                                     , (v2, toks2) <- p2 toks1
[14;1H                                                     , (v3, toks3) <- p3 toks2 ]
[15;1H                     
[16;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[17;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[18;1H                     pThen4 combine p1 p2 p3 p4 toks
[19;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[20;1H                                                        , (v2, toks2) <- p2 toks1
[21;1H                                                        , (v3, toks3) <- p3 toks2
[22;1H                                                        , (v4, toks4) <- p4 toks3 ]
[23;1H                     
[24;1H                     pZeroOrMore :: Parser a -> Parser [a]
[25;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[26;1H                     
[27;1H                     pOneOrMore :: Parser a -> Parser [a]
[28;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[29;1H                     
[30;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[31;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[32;1H                     
[33;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[34;1H                     (<$$>) = flip pApply
[35;1H                     
[36;1H                     (<$$) :: a -> Parser b -> Parser a
[37;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     pEmpty x toks = [(x, toks)]
[2;1H                     
[3;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[4;1H                     pThen combine p1 p2 toks
[5;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[6;1H                                                  , (v2, toks2) <- p2 toks1 ]
[7;1H                     
[8;1H                     pThen3 :: (a -> b -> c -> d) 
[9;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[10;1H                     pThen3 combine p1 p2 p3 toks
[11;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[12;1H                                                     , (v2, toks2) <- p2 toks1
[13;1H                                                     , (v3, toks3) <- p3 toks2 ]
[14;1H                     
[15;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[16;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[17;1H                     pThen4 combine p1 p2 p3 p4 toks
[18;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[19;1H                                                        , (v2, toks2) <- p2 toks1
[20;1H                                                        , (v3, toks3) <- p3 toks2
[21;1H                                                        , (v4, toks4) <- p4 toks3 ]
[22;1H                     
[23;1H                     pZeroOrMore :: Parser a -> Parser [a]
[24;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[25;1H                     
[26;1H                     pOneOrMore :: Parser a -> Parser [a]
[27;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[28;1H                     
[29;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[30;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[31;1H                     
[32;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[33;1H                     (<$$>) = flip pApply
[34;1H                     
[35;1H                     (<$$) :: a -> Parser b -> Parser a
[36;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[37;1H                     
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     
[2;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[3;1H                     pThen combine p1 p2 toks
[4;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[5;1H                                                  , (v2, toks2) <- p2 toks1 ]
[6;1H                     
[7;1H                     pThen3 :: (a -> b -> c -> d) 
[8;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[9;1H                     pThen3 combine p1 p2 p3 toks
[10;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[11;1H                                                     , (v2, toks2) <- p2 toks1
[12;1H                                                     , (v3, toks3) <- p3 toks2 ]
[13;1H                     
[14;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[15;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[16;1H                     pThen4 combine p1 p2 p3 p4 toks
[17;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[18;1H                                                        , (v2, toks2) <- p2 toks1
[19;1H                                                        , (v3, toks3) <- p3 toks2
[20;1H                                                        , (v4, toks4) <- p4 toks3 ]
[21;1H                     
[22;1H                     pZeroOrMore :: Parser a -> Parser [a]
[23;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[24;1H                     
[25;1H                     pOneOrMore :: Parser a -> Parser [a]
[26;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[27;1H                     
[28;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[29;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[30;1H                     
[31;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[32;1H                     (<$$>) = flip pApply
[33;1H                     
[34;1H                     (<$$) :: a -> Parser b -> Parser a
[35;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[36;1H                     
[37;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
[2;1H                     pThen combine p1 p2 toks
[3;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[4;1H                                                  , (v2, toks2) <- p2 toks1 ]
[5;1H                     
[6;1H                     pThen3 :: (a -> b -> c -> d) 
[7;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[8;1H                     pThen3 combine p1 p2 p3 toks
[9;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[10;1H                                                     , (v2, toks2) <- p2 toks1
[11;1H                                                     , (v3, toks3) <- p3 toks2 ]
[12;1H                     
[13;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[14;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[15;1H                     pThen4 combine p1 p2 p3 p4 toks
[16;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[17;1H                                                        , (v2, toks2) <- p2 toks1
[18;1H                                                        , (v3, toks3) <- p3 toks2
[19;1H                                                        , (v4, toks4) <- p4 toks3 ]
[20;1H                     
[21;1H                     pZeroOrMore :: Parser a -> Parser [a]
[22;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[23;1H                     
[24;1H                     pOneOrMore :: Parser a -> Parser [a]
[25;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[26;1H                     
[27;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[28;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[29;1H                     
[30;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[31;1H                     (<$$>) = flip pApply
[32;1H                     
[33;1H                     (<$$) :: a -> Parser b -> Parser a
[34;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[35;1H                     
[36;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[37;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     pThen combine p1 p2 toks
[2;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[3;1H                                                  , (v2, toks2) <- p2 toks1 ]
[4;1H                     
[5;1H                     pThen3 :: (a -> b -> c -> d) 
[6;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[7;1H                     pThen3 combine p1 p2 p3 toks
[8;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[9;1H                                                     , (v2, toks2) <- p2 toks1
[10;1H                                                     , (v3, toks3) <- p3 toks2 ]
[11;1H                     
[12;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[13;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[14;1H                     pThen4 combine p1 p2 p3 p4 toks
[15;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[16;1H                                                        , (v2, toks2) <- p2 toks1
[17;1H                                                        , (v3, toks3) <- p3 toks2
[18;1H                                                        , (v4, toks4) <- p4 toks3 ]
[19;1H                     
[20;1H                     pZeroOrMore :: Parser a -> Parser [a]
[21;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[22;1H                     
[23;1H                     pOneOrMore :: Parser a -> Parser [a]
[24;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[25;1H                     
[26;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[27;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[28;1H                     
[29;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[30;1H                     (<$$>) = flip pApply
[31;1H                     
[32;1H                     (<$$) :: a -> Parser b -> Parser a
[33;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[34;1H                     
[35;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[36;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[37;1H                                                        , (x, toks2) <- px toks1 ]
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                       = [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks
[2;1H                                                  , (v2, toks2) <- p2 toks1 ]
[3;1H                     
[4;1H                     pThen3 :: (a -> b -> c -> d) 
[5;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[6;1H                     pThen3 combine p1 p2 p3 toks
[7;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[8;1H                                                     , (v2, toks2) <- p2 toks1
[9;1H                                                     , (v3, toks3) <- p3 toks2 ]
[10;1H                     
[11;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[12;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[13;1H                     pThen4 combine p1 p2 p3 p4 toks
[14;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[15;1H                                                        , (v2, toks2) <- p2 toks1
[16;1H                                                        , (v3, toks3) <- p3 toks2
[17;1H                                                        , (v4, toks4) <- p4 toks3 ]
[18;1H                     
[19;1H                     pZeroOrMore :: Parser a -> Parser [a]
[20;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[21;1H                     
[22;1H                     pOneOrMore :: Parser a -> Parser [a]
[23;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[24;1H                     
[25;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[26;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[27;1H                     
[28;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[29;1H                     (<$$>) = flip pApply
[30;1H                     
[31;1H                     (<$$) :: a -> Parser b -> Parser a
[32;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[33;1H                     
[34;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[35;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[36;1H                                                        , (x, toks2) <- px toks1 ]
[37;1H                     
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                                                  , (v2, toks2) <- p2 toks1 ]
[2;1H                     
[3;1H                     pThen3 :: (a -> b -> c -> d) 
[4;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[5;1H                     pThen3 combine p1 p2 p3 toks
[6;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[7;1H                                                     , (v2, toks2) <- p2 toks1
[8;1H                                                     , (v3, toks3) <- p3 toks2 ]
[9;1H                     
[10;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[11;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[12;1H                     pThen4 combine p1 p2 p3 p4 toks
[13;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[14;1H                                                        , (v2, toks2) <- p2 toks1
[15;1H                                                        , (v3, toks3) <- p3 toks2
[16;1H                                                        , (v4, toks4) <- p4 toks3 ]
[17;1H                     
[18;1H                     pZeroOrMore :: Parser a -> Parser [a]
[19;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[20;1H                     
[21;1H                     pOneOrMore :: Parser a -> Parser [a]
[22;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[23;1H                     
[24;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[25;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[26;1H                     
[27;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[28;1H                     (<$$>) = flip pApply
[29;1H                     
[30;1H                     (<$$) :: a -> Parser b -> Parser a
[31;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[32;1H                     
[33;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[34;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[35;1H                                                        , (x, toks2) <- px toks1 ]
[36;1H                     
[37;1H                     (<**) :: Parser a -> Parser b -> Parser a
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     
[2;1H                     pThen3 :: (a -> b -> c -> d) 
[3;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[4;1H                     pThen3 combine p1 p2 p3 toks
[5;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[6;1H                                                     , (v2, toks2) <- p2 toks1
[7;1H                                                     , (v3, toks3) <- p3 toks2 ]
[8;1H                     
[9;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[10;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[11;1H                     pThen4 combine p1 p2 p3 p4 toks
[12;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[13;1H                                                        , (v2, toks2) <- p2 toks1
[14;1H                                                        , (v3, toks3) <- p3 toks2
[15;1H                                                        , (v4, toks4) <- p4 toks3 ]
[16;1H                     
[17;1H                     pZeroOrMore :: Parser a -> Parser [a]
[18;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[19;1H                     
[20;1H                     pOneOrMore :: Parser a -> Parser [a]
[21;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[22;1H                     
[23;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[24;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[25;1H                     
[26;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[27;1H                     (<$$>) = flip pApply
[28;1H                     
[29;1H                     (<$$) :: a -> Parser b -> Parser a
[30;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[31;1H                     
[32;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[33;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[34;1H                                                        , (x, toks2) <- px toks1 ]
[35;1H                     
[36;1H                     (<**) :: Parser a -> Parser b -> Parser a
[37;1H                     p1 <** p2 = const <$$> p1 <**> p2
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     pThen3 :: (a -> b -> c -> d) 
[2;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[3;1H                     pThen3 combine p1 p2 p3 toks
[4;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[5;1H                                                     , (v2, toks2) <- p2 toks1
[6;1H                                                     , (v3, toks3) <- p3 toks2 ]
[7;1H                     
[8;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[9;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[10;1H                     pThen4 combine p1 p2 p3 p4 toks
[11;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[12;1H                                                        , (v2, toks2) <- p2 toks1
[13;1H                                                        , (v3, toks3) <- p3 toks2
[14;1H                                                        , (v4, toks4) <- p4 toks3 ]
[15;1H                     
[16;1H                     pZeroOrMore :: Parser a -> Parser [a]
[17;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[18;1H                     
[19;1H                     pOneOrMore :: Parser a -> Parser [a]
[20;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[21;1H                     
[22;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[23;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[24;1H                     
[25;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[26;1H                     (<$$>) = flip pApply
[27;1H                     
[28;1H                     (<$$) :: a -> Parser b -> Parser a
[29;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[30;1H                     
[31;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[32;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[33;1H                                                        , (x, toks2) <- px toks1 ]
[34;1H                     
[35;1H                     (<**) :: Parser a -> Parser b -> Parser a
[36;1H                     p1 <** p2 = const <$$> p1 <**> p2
[37;1H                     
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                            -> Parser a -> Parser b -> Parser c -> Parser d
[2;1H                     pThen3 combine p1 p2 p3 toks
[3;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[4;1H                                                     , (v2, toks2) <- p2 toks1
[5;1H                                                     , (v3, toks3) <- p3 toks2 ]
[6;1H                     
[7;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[8;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[9;1H                     pThen4 combine p1 p2 p3 p4 toks
[10;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[11;1H                                                        , (v2, toks2) <- p2 toks1
[12;1H                                                        , (v3, toks3) <- p3 toks2
[13;1H                                                        , (v4, toks4) <- p4 toks3 ]
[14;1H                     
[15;1H                     pZeroOrMore :: Parser a -> Parser [a]
[16;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[17;1H                     
[18;1H                     pOneOrMore :: Parser a -> Parser [a]
[19;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[20;1H                     
[21;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[22;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[23;1H                     
[24;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[25;1H                     (<$$>) = flip pApply
[26;1H                     
[27;1H                     (<$$) :: a -> Parser b -> Parser a
[28;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[29;1H                     
[30;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[31;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[32;1H                                                        , (x, toks2) <- px toks1 ]
[33;1H                     
[34;1H                     (<**) :: Parser a -> Parser b -> Parser a
[35;1H                     p1 <** p2 = const <$$> p1 <**> p2
[36;1H                     
[37;1H                     (**>) :: Parser a -> Parser b -> Parser b
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     pThen3 combine p1 p2 p3 toks
[2;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[3;1H                                                     , (v2, toks2) <- p2 toks1
[4;1H                                                     , (v3, toks3) <- p3 toks2 ]
[5;1H                     
[6;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[7;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[8;1H                     pThen4 combine p1 p2 p3 p4 toks
[9;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[10;1H                                                        , (v2, toks2) <- p2 toks1
[11;1H                                                        , (v3, toks3) <- p3 toks2
[12;1H                                                        , (v4, toks4) <- p4 toks3 ]
[13;1H                     
[14;1H                     pZeroOrMore :: Parser a -> Parser [a]
[15;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[16;1H                     
[17;1H                     pOneOrMore :: Parser a -> Parser [a]
[18;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[19;1H                     
[20;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[21;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[22;1H                     
[23;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[24;1H                     (<$$>) = flip pApply
[25;1H                     
[26;1H                     (<$$) :: a -> Parser b -> Parser a
[27;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[28;1H                     
[29;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[30;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[31;1H                                                        , (x, toks2) <- px toks1 ]
[32;1H                     
[33;1H                     (<**) :: Parser a -> Parser b -> Parser a
[34;1H                     p1 <** p2 = const <$$> p1 <**> p2
[35;1H                     
[36;1H                     (**>) :: Parser a -> Parser b -> Parser b
[37;1H                     p1 **> p2 = const id <$$> p1 <**> p2
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                       = [ (combine v1 v2 v3, toks3) | (v1, toks1) <- p1 toks
[2;1H                                                     , (v2, toks2) <- p2 toks1
[3;1H                                                     , (v3, toks3) <- p3 toks2 ]
[4;1H                     
[5;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[6;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[7;1H                     pThen4 combine p1 p2 p3 p4 toks
[8;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[9;1H                                                        , (v2, toks2) <- p2 toks1
[10;1H                                                        , (v3, toks3) <- p3 toks2
[11;1H                                                        , (v4, toks4) <- p4 toks3 ]
[12;1H                     
[13;1H                     pZeroOrMore :: Parser a -> Parser [a]
[14;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[15;1H                     
[16;1H                     pOneOrMore :: Parser a -> Parser [a]
[17;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[18;1H                     
[19;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[20;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[21;1H                     
[22;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[23;1H                     (<$$>) = flip pApply
[24;1H                     
[25;1H                     (<$$) :: a -> Parser b -> Parser a
[26;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[27;1H                     
[28;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[29;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[30;1H                                                        , (x, toks2) <- px toks1 ]
[31;1H                     
[32;1H                     (<**) :: Parser a -> Parser b -> Parser a
[33;1H                     p1 <** p2 = const <$$> p1 <**> p2
[34;1H                     
[35;1H                     (**>) :: Parser a -> Parser b -> Parser b
[36;1H                     p1 **> p2 = const id <$$> p1 <**> p2
[37;1H                     
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                                                     , (v2, toks2) <- p2 toks1
[2;1H                                                     , (v3, toks3) <- p3 toks2 ]
[3;1H                     
[4;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[5;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[6;1H                     pThen4 combine p1 p2 p3 p4 toks
[7;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[8;1H                                                        , (v2, toks2) <- p2 toks1
[9;1H                                                        , (v3, toks3) <- p3 toks2
[10;1H                                                        , (v4, toks4) <- p4 toks3 ]
[11;1H                     
[12;1H                     pZeroOrMore :: Parser a -> Parser [a]
[13;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[14;1H                     
[15;1H                     pOneOrMore :: Parser a -> Parser [a]
[16;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[17;1H                     
[18;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[19;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[20;1H                     
[21;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[22;1H                     (<$$>) = flip pApply
[23;1H                     
[24;1H                     (<$$) :: a -> Parser b -> Parser a
[25;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[26;1H                     
[27;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[28;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[29;1H                                                        , (x, toks2) <- px toks1 ]
[30;1H                     
[31;1H                     (<**) :: Parser a -> Parser b -> Parser a
[32;1H                     p1 <** p2 = const <$$> p1 <**> p2
[33;1H                     
[34;1H                     (**>) :: Parser a -> Parser b -> Parser b
[35;1H                     p1 **> p2 = const id <$$> p1 <**> p2
[36;1H                     
[37;1H                     {-
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                                                     , (v3, toks3) <- p3 toks2 ]
[2;1H                     
[3;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[4;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[5;1H                     pThen4 combine p1 p2 p3 p4 toks
[6;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[7;1H                                                        , (v2, toks2) <- p2 toks1
[8;1H                                                        , (v3, toks3) <- p3 toks2
[9;1H                                                        , (v4, toks4) <- p4 toks3 ]
[10;1H                     
[11;1H                     pZeroOrMore :: Parser a -> Parser [a]
[12;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[13;1H                     
[14;1H                     pOneOrMore :: Parser a -> Parser [a]
[15;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[16;1H                     
[17;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[18;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[19;1H                     
[20;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[21;1H                     (<$$>) = flip pApply
[22;1H                     
[23;1H                     (<$$) :: a -> Parser b -> Parser a
[24;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[25;1H                     
[26;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[27;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[28;1H                                                        , (x, toks2) <- px toks1 ]
[29;1H                     
[30;1H                     (<**) :: Parser a -> Parser b -> Parser a
[31;1H                     p1 <** p2 = const <$$> p1 <**> p2
[32;1H                     
[33;1H                     (**>) :: Parser a -> Parser b -> Parser b
[34;1H                     p1 **> p2 = const id <$$> p1 <**> p2
[35;1H                     
[36;1H                     {-
[37;1H                     pThen  combine p1 p2 = combine <$$> p1 <**> p2
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     
[2;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[3;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[4;1H                     pThen4 combine p1 p2 p3 p4 toks
[5;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[6;1H                                                        , (v2, toks2) <- p2 toks1
[7;1H                                                        , (v3, toks3) <- p3 toks2
[8;1H                                                        , (v4, toks4) <- p4 toks3 ]
[9;1H                     
[10;1H                     pZeroOrMore :: Parser a -> Parser [a]
[11;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[12;1H                     
[13;1H                     pOneOrMore :: Parser a -> Parser [a]
[14;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[15;1H                     
[16;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[17;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[18;1H                     
[19;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[20;1H                     (<$$>) = flip pApply
[21;1H                     
[22;1H                     (<$$) :: a -> Parser b -> Parser a
[23;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[24;1H                     
[25;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[26;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[27;1H                                                        , (x, toks2) <- px toks1 ]
[28;1H                     
[29;1H                     (<**) :: Parser a -> Parser b -> Parser a
[30;1H                     p1 <** p2 = const <$$> p1 <**> p2
[31;1H                     
[32;1H                     (**>) :: Parser a -> Parser b -> Parser b
[33;1H                     p1 **> p2 = const id <$$> p1 <**> p2
[34;1H                     
[35;1H                     {-
[36;1H                     pThen  combine p1 p2 = combine <$$> p1 <**> p2
[37;1H                     pThen3 combine p1 p2 p3 = combine <$$> p1 <**> p2 <**> p3
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     pThen4 :: (a -> b -> c -> d -> e) 
[2;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[3;1H                     pThen4 combine p1 p2 p3 p4 toks
[4;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[5;1H                                                        , (v2, toks2) <- p2 toks1
[6;1H                                                        , (v3, toks3) <- p3 toks2
[7;1H                                                        , (v4, toks4) <- p4 toks3 ]
[8;1H                     
[9;1H                     pZeroOrMore :: Parser a -> Parser [a]
[10;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[11;1H                     
[12;1H                     pOneOrMore :: Parser a -> Parser [a]
[13;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[14;1H                     
[15;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[16;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[17;1H                     
[18;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[19;1H                     (<$$>) = flip pApply
[20;1H                     
[21;1H                     (<$$) :: a -> Parser b -> Parser a
[22;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[23;1H                     
[24;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[25;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[26;1H                                                        , (x, toks2) <- px toks1 ]
[27;1H                     
[28;1H                     (<**) :: Parser a -> Parser b -> Parser a
[29;1H                     p1 <** p2 = const <$$> p1 <**> p2
[30;1H                     
[31;1H                     (**>) :: Parser a -> Parser b -> Parser b
[32;1H                     p1 **> p2 = const id <$$> p1 <**> p2
[33;1H                     
[34;1H                     {-
[35;1H                     pThen  combine p1 p2 = combine <$$> p1 <**> p2
[36;1H                     pThen3 combine p1 p2 p3 = combine <$$> p1 <**> p2 <**> p3
[37;1H                     pThen4 combine p1 p2 p3 p4 = combine <$$> p1 <**> p2 <**> p3 <**> p4
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                            -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
[2;1H                     pThen4 combine p1 p2 p3 p4 toks
[3;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[4;1H                                                        , (v2, toks2) <- p2 toks1
[5;1H                                                        , (v3, toks3) <- p3 toks2
[6;1H                                                        , (v4, toks4) <- p4 toks3 ]
[7;1H                     
[8;1H                     pZeroOrMore :: Parser a -> Parser [a]
[9;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[10;1H                     
[11;1H                     pOneOrMore :: Parser a -> Parser [a]
[12;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[13;1H                     
[14;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[15;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[16;1H                     
[17;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[18;1H                     (<$$>) = flip pApply
[19;1H                     
[20;1H                     (<$$) :: a -> Parser b -> Parser a
[21;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[22;1H                     
[23;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[24;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[25;1H                                                        , (x, toks2) <- px toks1 ]
[26;1H                     
[27;1H                     (<**) :: Parser a -> Parser b -> Parser a
[28;1H                     p1 <** p2 = const <$$> p1 <**> p2
[29;1H                     
[30;1H                     (**>) :: Parser a -> Parser b -> Parser b
[31;1H                     p1 **> p2 = const id <$$> p1 <**> p2
[32;1H                     
[33;1H                     {-
[34;1H                     pThen  combine p1 p2 = combine <$$> p1 <**> p2
[35;1H                     pThen3 combine p1 p2 p3 = combine <$$> p1 <**> p2 <**> p3
[36;1H                     pThen4 combine p1 p2 p3 p4 = combine <$$> p1 <**> p2 <**> p3 <**> p4
[37;1H                     -}
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     pThen4 combine p1 p2 p3 p4 toks
[2;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[3;1H                                                        , (v2, toks2) <- p2 toks1
[4;1H                                                        , (v3, toks3) <- p3 toks2
[5;1H                                                        , (v4, toks4) <- p4 toks3 ]
[6;1H                     
[7;1H                     pZeroOrMore :: Parser a -> Parser [a]
[8;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[9;1H                     
[10;1H                     pOneOrMore :: Parser a -> Parser [a]
[11;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[12;1H                     
[13;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[14;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[15;1H                     
[16;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[17;1H                     (<$$>) = flip pApply
[18;1H                     
[19;1H                     (<$$) :: a -> Parser b -> Parser a
[20;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[21;1H                     
[22;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[23;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[24;1H                                                        , (x, toks2) <- px toks1 ]
[25;1H                     
[26;1H                     (<**) :: Parser a -> Parser b -> Parser a
[27;1H                     p1 <** p2 = const <$$> p1 <**> p2
[28;1H                     
[29;1H                     (**>) :: Parser a -> Parser b -> Parser b
[30;1H                     p1 **> p2 = const id <$$> p1 <**> p2
[31;1H                     
[32;1H                     {-
[33;1H                     pThen  combine p1 p2 = combine <$$> p1 <**> p2
[34;1H                     pThen3 combine p1 p2 p3 = combine <$$> p1 <**> p2 <**> p3
[35;1H                     pThen4 combine p1 p2 p3 p4 = combine <$$> p1 <**> p2 <**> p3 <**> p4
[36;1H                     -}
[37;1H                     
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                       = [ (combine v1 v2 v3 v4, toks4) | (v1, toks1) <- p1 toks
[2;1H                                                        , (v2, toks2) <- p2 toks1
[3;1H                                                        , (v3, toks3) <- p3 toks2
[4;1H                                                        , (v4, toks4) <- p4 toks3 ]
[5;1H                     
[6;1H                     pZeroOrMore :: Parser a -> Parser [a]
[7;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[8;1H                     
[9;1H                     pOneOrMore :: Parser a -> Parser [a]
[10;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[11;1H                     
[12;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[13;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[14;1H                     
[15;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[16;1H                     (<$$>) = flip pApply
[17;1H                     
[18;1H                     (<$$) :: a -> Parser b -> Parser a
[19;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[20;1H                     
[21;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[22;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[23;1H                                                        , (x, toks2) <- px toks1 ]
[24;1H                     
[25;1H                     (<**) :: Parser a -> Parser b -> Parser a
[26;1H                     p1 <** p2 = const <$$> p1 <**> p2
[27;1H                     
[28;1H                     (**>) :: Parser a -> Parser b -> Parser b
[29;1H                     p1 **> p2 = const id <$$> p1 <**> p2
[30;1H                     
[31;1H                     {-
[32;1H                     pThen  combine p1 p2 = combine <$$> p1 <**> p2
[33;1H                     pThen3 combine p1 p2 p3 = combine <$$> p1 <**> p2 <**> p3
[34;1H                     pThen4 combine p1 p2 p3 p4 = combine <$$> p1 <**> p2 <**> p3 <**> p4
[35;1H                     -}
[36;1H                     
[37;1H                     infixl 4 <$$>, <$$, <**>, <**, **>
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                                                        , (v2, toks2) <- p2 toks1
[2;1H                                                        , (v3, toks3) <- p3 toks2
[3;1H                                                        , (v4, toks4) <- p4 toks3 ]
[4;1H                     
[5;1H                     pZeroOrMore :: Parser a -> Parser [a]
[6;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[7;1H                     
[8;1H                     pOneOrMore :: Parser a -> Parser [a]
[9;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[10;1H                     
[11;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[12;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[13;1H                     
[14;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[15;1H                     (<$$>) = flip pApply
[16;1H                     
[17;1H                     (<$$) :: a -> Parser b -> Parser a
[18;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[19;1H                     
[20;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[21;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[22;1H                                                        , (x, toks2) <- px toks1 ]
[23;1H                     
[24;1H                     (<**) :: Parser a -> Parser b -> Parser a
[25;1H                     p1 <** p2 = const <$$> p1 <**> p2
[26;1H                     
[27;1H                     (**>) :: Parser a -> Parser b -> Parser b
[28;1H                     p1 **> p2 = const id <$$> p1 <**> p2
[29;1H                     
[30;1H                     {-
[31;1H                     pThen  combine p1 p2 = combine <$$> p1 <**> p2
[32;1H                     pThen3 combine p1 p2 p3 = combine <$$> p1 <**> p2 <**> p3
[33;1H                     pThen4 combine p1 p2 p3 p4 = combine <$$> p1 <**> p2 <**> p3 <**> p4
[34;1H                     -}
[35;1H                     
[36;1H                     infixl 4 <$$>, <$$, <**>, <**, **>
[37;1H                     
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                                                        , (v3, toks3) <- p3 toks2
[2;1H                                                        , (v4, toks4) <- p4 toks3 ]
[3;1H                     
[4;1H                     pZeroOrMore :: Parser a -> Parser [a]
[5;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[6;1H                     
[7;1H                     pOneOrMore :: Parser a -> Parser [a]
[8;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[9;1H                     
[10;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[11;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[12;1H                     
[13;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[14;1H                     (<$$>) = flip pApply
[15;1H                     
[16;1H                     (<$$) :: a -> Parser b -> Parser a
[17;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[18;1H                     
[19;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[20;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[21;1H                                                        , (x, toks2) <- px toks1 ]
[22;1H                     
[23;1H                     (<**) :: Parser a -> Parser b -> Parser a
[24;1H                     p1 <** p2 = const <$$> p1 <**> p2
[25;1H                     
[26;1H                     (**>) :: Parser a -> Parser b -> Parser b
[27;1H                     p1 **> p2 = const id <$$> p1 <**> p2
[28;1H                     
[29;1H                     {-
[30;1H                     pThen  combine p1 p2 = combine <$$> p1 <**> p2
[31;1H                     pThen3 combine p1 p2 p3 = combine <$$> p1 <**> p2 <**> p3
[32;1H                     pThen4 combine p1 p2 p3 p4 = combine <$$> p1 <**> p2 <**> p3 <**> p4
[33;1H                     -}
[34;1H                     
[35;1H                     infixl 4 <$$>, <$$, <**>, <**, **>
[36;1H                     
[37;1H                     pMunch :: Parser a -> Parser [a]
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                                                        , (v4, toks4) <- p4 toks3 ]
[2;1H                     
[3;1H                     pZeroOrMore :: Parser a -> Parser [a]
[4;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[5;1H                     
[6;1H                     pOneOrMore :: Parser a -> Parser [a]
[7;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[8;1H                     
[9;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[10;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[11;1H                     
[12;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[13;1H                     (<$$>) = flip pApply
[14;1H                     
[15;1H                     (<$$) :: a -> Parser b -> Parser a
[16;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[17;1H                     
[18;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[19;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[20;1H                                                        , (x, toks2) <- px toks1 ]
[21;1H                     
[22;1H                     (<**) :: Parser a -> Parser b -> Parser a
[23;1H                     p1 <** p2 = const <$$> p1 <**> p2
[24;1H                     
[25;1H                     (**>) :: Parser a -> Parser b -> Parser b
[26;1H                     p1 **> p2 = const id <$$> p1 <**> p2
[27;1H                     
[28;1H                     {-
[29;1H                     pThen  combine p1 p2 = combine <$$> p1 <**> p2
[30;1H                     pThen3 combine p1 p2 p3 = combine <$$> p1 <**> p2 <**> p3
[31;1H                     pThen4 combine p1 p2 p3 p4 = combine <$$> p1 <**> p2 <**> p3 <**> p4
[32;1H                     -}
[33;1H                     
[34;1H                     infixl 4 <$$>, <$$, <**>, <**, **>
[35;1H                     
[36;1H                     pMunch :: Parser a -> Parser [a]
[37;1H                     pMunch p = pMunch1 p `pAlt'` pEmpty []
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     
[2;1H                     pZeroOrMore :: Parser a -> Parser [a]
[3;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[4;1H                     
[5;1H                     pOneOrMore :: Parser a -> Parser [a]
[6;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[7;1H                     
[8;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[9;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[10;1H                     
[11;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[12;1H                     (<$$>) = flip pApply
[13;1H                     
[14;1H                     (<$$) :: a -> Parser b -> Parser a
[15;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[16;1H                     
[17;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[18;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[19;1H                                                        , (x, toks2) <- px toks1 ]
[20;1H                     
[21;1H                     (<**) :: Parser a -> Parser b -> Parser a
[22;1H                     p1 <** p2 = const <$$> p1 <**> p2
[23;1H                     
[24;1H                     (**>) :: Parser a -> Parser b -> Parser b
[25;1H                     p1 **> p2 = const id <$$> p1 <**> p2
[26;1H                     
[27;1H                     {-
[28;1H                     pThen  combine p1 p2 = combine <$$> p1 <**> p2
[29;1H                     pThen3 combine p1 p2 p3 = combine <$$> p1 <**> p2 <**> p3
[30;1H                     pThen4 combine p1 p2 p3 p4 = combine <$$> p1 <**> p2 <**> p3 <**> p4
[31;1H                     -}
[32;1H                     
[33;1H                     infixl 4 <$$>, <$$, <**>, <**, **>
[34;1H                     
[35;1H                     pMunch :: Parser a -> Parser [a]
[36;1H                     pMunch p = pMunch1 p `pAlt'` pEmpty []
[37;1H                     
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     pZeroOrMore :: Parser a -> Parser [a]
[2;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[3;1H                     
[4;1H                     pOneOrMore :: Parser a -> Parser [a]
[5;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[6;1H                     
[7;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[8;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[9;1H                     
[10;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[11;1H                     (<$$>) = flip pApply
[12;1H                     
[13;1H                     (<$$) :: a -> Parser b -> Parser a
[14;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[15;1H                     
[16;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[17;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[18;1H                                                        , (x, toks2) <- px toks1 ]
[19;1H                     
[20;1H                     (<**) :: Parser a -> Parser b -> Parser a
[21;1H                     p1 <** p2 = const <$$> p1 <**> p2
[22;1H                     
[23;1H                     (**>) :: Parser a -> Parser b -> Parser b
[24;1H                     p1 **> p2 = const id <$$> p1 <**> p2
[25;1H                     
[26;1H                     {-
[27;1H                     pThen  combine p1 p2 = combine <$$> p1 <**> p2
[28;1H                     pThen3 combine p1 p2 p3 = combine <$$> p1 <**> p2 <**> p3
[29;1H                     pThen4 combine p1 p2 p3 p4 = combine <$$> p1 <**> p2 <**> p3 <**> p4
[30;1H                     -}
[31;1H                     
[32;1H                     infixl 4 <$$>, <$$, <**>, <**, **>
[33;1H                     
[34;1H                     pMunch :: Parser a -> Parser [a]
[35;1H                     pMunch p = pMunch1 p `pAlt'` pEmpty []
[36;1H                     
[37;1H                     pMunch1 :: Parser a -> Parser [a]
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []
[2;1H                     
[3;1H                     pOneOrMore :: Parser a -> Parser [a]
[4;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[5;1H                     
[6;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[7;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[8;1H                     
[9;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[10;1H                     (<$$>) = flip pApply
[11;1H                     
[12;1H                     (<$$) :: a -> Parser b -> Parser a
[13;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[14;1H                     
[15;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[16;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[17;1H                                                        , (x, toks2) <- px toks1 ]
[18;1H                     
[19;1H                     (<**) :: Parser a -> Parser b -> Parser a
[20;1H                     p1 <** p2 = const <$$> p1 <**> p2
[21;1H                     
[22;1H                     (**>) :: Parser a -> Parser b -> Parser b
[23;1H                     p1 **> p2 = const id <$$> p1 <**> p2
[24;1H                     
[25;1H                     {-
[26;1H                     pThen  combine p1 p2 = combine <$$> p1 <**> p2
[27;1H                     pThen3 combine p1 p2 p3 = combine <$$> p1 <**> p2 <**> p3
[28;1H                     pThen4 combine p1 p2 p3 p4 = combine <$$> p1 <**> p2 <**> p3 <**> p4
[29;1H                     -}
[30;1H                     
[31;1H                     infixl 4 <$$>, <$$, <**>, <**, **>
[32;1H                     
[33;1H                     pMunch :: Parser a -> Parser [a]
[34;1H                     pMunch p = pMunch1 p `pAlt'` pEmpty []
[35;1H                     
[36;1H                     pMunch1 :: Parser a -> Parser [a]
[37;1H                     pMunch1 p = (:) <$$> p <**> pMunch p
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     
[2;1H                     pOneOrMore :: Parser a -> Parser [a]
[3;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[4;1H                     
[5;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[6;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[7;1H                     
[8;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[9;1H                     (<$$>) = flip pApply
[10;1H                     
[11;1H                     (<$$) :: a -> Parser b -> Parser a
[12;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[13;1H                     
[14;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[15;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[16;1H                                                        , (x, toks2) <- px toks1 ]
[17;1H                     
[18;1H                     (<**) :: Parser a -> Parser b -> Parser a
[19;1H                     p1 <** p2 = const <$$> p1 <**> p2
[20;1H                     
[21;1H                     (**>) :: Parser a -> Parser b -> Parser b
[22;1H                     p1 **> p2 = const id <$$> p1 <**> p2
[23;1H                     
[24;1H                     {-
[25;1H                     pThen  combine p1 p2 = combine <$$> p1 <**> p2
[26;1H                     pThen3 combine p1 p2 p3 = combine <$$> p1 <**> p2 <**> p3
[27;1H                     pThen4 combine p1 p2 p3 p4 = combine <$$> p1 <**> p2 <**> p3 <**> p4
[28;1H                     -}
[29;1H                     
[30;1H                     infixl 4 <$$>, <$$, <**>, <**, **>
[31;1H                     
[32;1H                     pMunch :: Parser a -> Parser [a]
[33;1H                     pMunch p = pMunch1 p `pAlt'` pEmpty []
[34;1H                     
[35;1H                     pMunch1 :: Parser a -> Parser [a]
[36;1H                     pMunch1 p = (:) <$$> p <**> pMunch p
[37;1H                     
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     pOneOrMore :: Parser a -> Parser [a]
[2;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[3;1H                     
[4;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[5;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[6;1H                     
[7;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[8;1H                     (<$$>) = flip pApply
[9;1H                     
[10;1H                     (<$$) :: a -> Parser b -> Parser a
[11;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[12;1H                     
[13;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[14;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[15;1H                                                        , (x, toks2) <- px toks1 ]
[16;1H                     
[17;1H                     (<**) :: Parser a -> Parser b -> Parser a
[18;1H                     p1 <** p2 = const <$$> p1 <**> p2
[19;1H                     
[20;1H                     (**>) :: Parser a -> Parser b -> Parser b
[21;1H                     p1 **> p2 = const id <$$> p1 <**> p2
[22;1H                     
[23;1H                     {-
[24;1H                     pThen  combine p1 p2 = combine <$$> p1 <**> p2
[25;1H                     pThen3 combine p1 p2 p3 = combine <$$> p1 <**> p2 <**> p3
[26;1H                     pThen4 combine p1 p2 p3 p4 = combine <$$> p1 <**> p2 <**> p3 <**> p4
[27;1H                     -}
[28;1H                     
[29;1H                     infixl 4 <$$>, <$$, <**>, <**, **>
[30;1H                     
[31;1H                     pMunch :: Parser a -> Parser [a]
[32;1H                     pMunch p = pMunch1 p `pAlt'` pEmpty []
[33;1H                     
[34;1H                     pMunch1 :: Parser a -> Parser [a]
[35;1H                     pMunch1 p = (:) <$$> p <**> pMunch p
[36;1H                     
[37;1H                     pOneOrMoreWithSep :: Parser a -> Parser b -> Parser [a]
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     pOneOrMore p = pThen (:) p (pZeroOrMore p)
[2;1H                     
[3;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[4;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[5;1H                     
[6;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[7;1H                     (<$$>) = flip pApply
[8;1H                     
[9;1H                     (<$$) :: a -> Parser b -> Parser a
[10;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[11;1H                     
[12;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[13;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[14;1H                                                        , (x, toks2) <- px toks1 ]
[15;1H                     
[16;1H                     (<**) :: Parser a -> Parser b -> Parser a
[17;1H                     p1 <** p2 = const <$$> p1 <**> p2
[18;1H                     
[19;1H                     (**>) :: Parser a -> Parser b -> Parser b
[20;1H                     p1 **> p2 = const id <$$> p1 <**> p2
[21;1H                     
[22;1H                     {-
[23;1H                     pThen  combine p1 p2 = combine <$$> p1 <**> p2
[24;1H                     pThen3 combine p1 p2 p3 = combine <$$> p1 <**> p2 <**> p3
[25;1H                     pThen4 combine p1 p2 p3 p4 = combine <$$> p1 <**> p2 <**> p3 <**> p4
[26;1H                     -}
[27;1H                     
[28;1H                     infixl 4 <$$>, <$$, <**>, <**, **>
[29;1H                     
[30;1H                     pMunch :: Parser a -> Parser [a]
[31;1H                     pMunch p = pMunch1 p `pAlt'` pEmpty []
[32;1H                     
[33;1H                     pMunch1 :: Parser a -> Parser [a]
[34;1H                     pMunch1 p = (:) <$$> p <**> pMunch p
[35;1H                     
[36;1H                     pOneOrMoreWithSep :: Parser a -> Parser b -> Parser [a]
[37;1H                     pOneOrMoreWithSep p sep = (:) <$$> p <**> pMunch (sep **> p)
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     
[2;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[3;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[4;1H                     
[5;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[6;1H                     (<$$>) = flip pApply
[7;1H                     
[8;1H                     (<$$) :: a -> Parser b -> Parser a
[9;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[10;1H                     
[11;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[12;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[13;1H                                                        , (x, toks2) <- px toks1 ]
[14;1H                     
[15;1H                     (<**) :: Parser a -> Parser b -> Parser a
[16;1H                     p1 <** p2 = const <$$> p1 <**> p2
[17;1H                     
[18;1H                     (**>) :: Parser a -> Parser b -> Parser b
[19;1H                     p1 **> p2 = const id <$$> p1 <**> p2
[20;1H                     
[21;1H                     {-
[22;1H                     pThen  combine p1 p2 = combine <$$> p1 <**> p2
[23;1H                     pThen3 combine p1 p2 p3 = combine <$$> p1 <**> p2 <**> p3
[24;1H                     pThen4 combine p1 p2 p3 p4 = combine <$$> p1 <**> p2 <**> p3 <**> p4
[25;1H                     -}
[26;1H                     
[27;1H                     infixl 4 <$$>, <$$, <**>, <**, **>
[28;1H                     
[29;1H                     pMunch :: Parser a -> Parser [a]
[30;1H                     pMunch p = pMunch1 p `pAlt'` pEmpty []
[31;1H                     
[32;1H                     pMunch1 :: Parser a -> Parser [a]
[33;1H                     pMunch1 p = (:) <$$> p <**> pMunch p
[34;1H                     
[35;1H                     pOneOrMoreWithSep :: Parser a -> Parser b -> Parser [a]
[36;1H                     pOneOrMoreWithSep p sep = (:) <$$> p <**> pMunch (sep **> p)
[37;1H                     
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     pApply :: Parser a -> (a -> b) -> Parser b
[2;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[3;1H                     
[4;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[5;1H                     (<$$>) = flip pApply
[6;1H                     
[7;1H                     (<$$) :: a -> Parser b -> Parser a
[8;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[9;1H                     
[10;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[11;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[12;1H                                                        , (x, toks2) <- px toks1 ]
[13;1H                     
[14;1H                     (<**) :: Parser a -> Parser b -> Parser a
[15;1H                     p1 <** p2 = const <$$> p1 <**> p2
[16;1H                     
[17;1H                     (**>) :: Parser a -> Parser b -> Parser b
[18;1H                     p1 **> p2 = const id <$$> p1 <**> p2
[19;1H                     
[20;1H                     {-
[21;1H                     pThen  combine p1 p2 = combine <$$> p1 <**> p2
[22;1H                     pThen3 combine p1 p2 p3 = combine <$$> p1 <**> p2 <**> p3
[23;1H                     pThen4 combine p1 p2 p3 p4 = combine <$$> p1 <**> p2 <**> p3 <**> p4
[24;1H                     -}
[25;1H                     
[26;1H                     infixl 4 <$$>, <$$, <**>, <**, **>
[27;1H                     
[28;1H                     pMunch :: Parser a -> Parser [a]
[29;1H                     pMunch p = pMunch1 p `pAlt'` pEmpty []
[30;1H                     
[31;1H                     pMunch1 :: Parser a -> Parser [a]
[32;1H                     pMunch1 p = (:) <$$> p <**> pMunch p
[33;1H                     
[34;1H                     pOneOrMoreWithSep :: Parser a -> Parser b -> Parser [a]
[35;1H                     pOneOrMoreWithSep p sep = (:) <$$> p <**> pMunch (sep **> p)
[36;1H                     
[37;1H                     takeFirstParse :: [(a, [Token])] -> a
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     pApply p f toks = [ (f x, toks') | (x, toks') <- p toks]
[2;1H                     
[3;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[4;1H                     (<$$>) = flip pApply
[5;1H                     
[6;1H                     (<$$) :: a -> Parser b -> Parser a
[7;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[8;1H                     
[9;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[10;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[11;1H                                                        , (x, toks2) <- px toks1 ]
[12;1H                     
[13;1H                     (<**) :: Parser a -> Parser b -> Parser a
[14;1H                     p1 <** p2 = const <$$> p1 <**> p2
[15;1H                     
[16;1H                     (**>) :: Parser a -> Parser b -> Parser b
[17;1H                     p1 **> p2 = const id <$$> p1 <**> p2
[18;1H                     
[19;1H                     {-
[20;1H                     pThen  combine p1 p2 = combine <$$> p1 <**> p2
[21;1H                     pThen3 combine p1 p2 p3 = combine <$$> p1 <**> p2 <**> p3
[22;1H                     pThen4 combine p1 p2 p3 p4 = combine <$$> p1 <**> p2 <**> p3 <**> p4
[23;1H                     -}
[24;1H                     
[25;1H                     infixl 4 <$$>, <$$, <**>, <**, **>
[26;1H                     
[27;1H                     pMunch :: Parser a -> Parser [a]
[28;1H                     pMunch p = pMunch1 p `pAlt'` pEmpty []
[29;1H                     
[30;1H                     pMunch1 :: Parser a -> Parser [a]
[31;1H                     pMunch1 p = (:) <$$> p <**> pMunch p
[32;1H                     
[33;1H                     pOneOrMoreWithSep :: Parser a -> Parser b -> Parser [a]
[34;1H                     pOneOrMoreWithSep p sep = (:) <$$> p <**> pMunch (sep **> p)
[35;1H                     
[36;1H                     takeFirstParse :: [(a, [Token])] -> a
[37;1H                     takeFirstParse res = case res of
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     
[2;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[3;1H                     (<$$>) = flip pApply
[4;1H                     
[5;1H                     (<$$) :: a -> Parser b -> Parser a
[6;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[7;1H                     
[8;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[9;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[10;1H                                                        , (x, toks2) <- px toks1 ]
[11;1H                     
[12;1H                     (<**) :: Parser a -> Parser b -> Parser a
[13;1H                     p1 <** p2 = const <$$> p1 <**> p2
[14;1H                     
[15;1H                     (**>) :: Parser a -> Parser b -> Parser b
[16;1H                     p1 **> p2 = const id <$$> p1 <**> p2
[17;1H                     
[18;1H                     {-
[19;1H                     pThen  combine p1 p2 = combine <$$> p1 <**> p2
[20;1H                     pThen3 combine p1 p2 p3 = combine <$$> p1 <**> p2 <**> p3
[21;1H                     pThen4 combine p1 p2 p3 p4 = combine <$$> p1 <**> p2 <**> p3 <**> p4
[22;1H                     -}
[23;1H                     
[24;1H                     infixl 4 <$$>, <$$, <**>, <**, **>
[25;1H                     
[26;1H                     pMunch :: Parser a -> Parser [a]
[27;1H                     pMunch p = pMunch1 p `pAlt'` pEmpty []
[28;1H                     
[29;1H                     pMunch1 :: Parser a -> Parser [a]
[30;1H                     pMunch1 p = (:) <$$> p <**> pMunch p
[31;1H                     
[32;1H                     pOneOrMoreWithSep :: Parser a -> Parser b -> Parser [a]
[33;1H                     pOneOrMoreWithSep p sep = (:) <$$> p <**> pMunch (sep **> p)
[34;1H                     
[35;1H                     takeFirstParse :: [(a, [Token])] -> a
[36;1H                     takeFirstParse res = case res of
[37;1H                       (x, []) : _ 
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     (<$$>) :: (a -> b) -> (Parser a -> Parser b)
[2;1H                     (<$$>) = flip pApply
[3;1H                     
[4;1H                     (<$$) :: a -> Parser b -> Parser a
[5;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[6;1H                     
[7;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[8;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[9;1H                                                        , (x, toks2) <- px toks1 ]
[10;1H                     
[11;1H                     (<**) :: Parser a -> Parser b -> Parser a
[12;1H                     p1 <** p2 = const <$$> p1 <**> p2
[13;1H                     
[14;1H                     (**>) :: Parser a -> Parser b -> Parser b
[15;1H                     p1 **> p2 = const id <$$> p1 <**> p2
[16;1H                     
[17;1H                     {-
[18;1H                     pThen  combine p1 p2 = combine <$$> p1 <**> p2
[19;1H                     pThen3 combine p1 p2 p3 = combine <$$> p1 <**> p2 <**> p3
[20;1H                     pThen4 combine p1 p2 p3 p4 = combine <$$> p1 <**> p2 <**> p3 <**> p4
[21;1H                     -}
[22;1H                     
[23;1H                     infixl 4 <$$>, <$$, <**>, <**, **>
[24;1H                     
[25;1H                     pMunch :: Parser a -> Parser [a]
[26;1H                     pMunch p = pMunch1 p `pAlt'` pEmpty []
[27;1H                     
[28;1H                     pMunch1 :: Parser a -> Parser [a]
[29;1H                     pMunch1 p = (:) <$$> p <**> pMunch p
[30;1H                     
[31;1H                     pOneOrMoreWithSep :: Parser a -> Parser b -> Parser [a]
[32;1H                     pOneOrMoreWithSep p sep = (:) <$$> p <**> pMunch (sep **> p)
[33;1H                     
[34;1H                     takeFirstParse :: [(a, [Token])] -> a
[35;1H                     takeFirstParse res = case res of
[36;1H                       (x, []) : _ 
[37;1H                         -> x
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     (<$$>) = flip pApply
[2;1H                     
[3;1H                     (<$$) :: a -> Parser b -> Parser a
[4;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[5;1H                     
[6;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[7;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[8;1H                                                        , (x, toks2) <- px toks1 ]
[9;1H                     
[10;1H                     (<**) :: Parser a -> Parser b -> Parser a
[11;1H                     p1 <** p2 = const <$$> p1 <**> p2
[12;1H                     
[13;1H                     (**>) :: Parser a -> Parser b -> Parser b
[14;1H                     p1 **> p2 = const id <$$> p1 <**> p2
[15;1H                     
[16;1H                     {-
[17;1H                     pThen  combine p1 p2 = combine <$$> p1 <**> p2
[18;1H                     pThen3 combine p1 p2 p3 = combine <$$> p1 <**> p2 <**> p3
[19;1H                     pThen4 combine p1 p2 p3 p4 = combine <$$> p1 <**> p2 <**> p3 <**> p4
[20;1H                     -}
[21;1H                     
[22;1H                     infixl 4 <$$>, <$$, <**>, <**, **>
[23;1H                     
[24;1H                     pMunch :: Parser a -> Parser [a]
[25;1H                     pMunch p = pMunch1 p `pAlt'` pEmpty []
[26;1H                     
[27;1H                     pMunch1 :: Parser a -> Parser [a]
[28;1H                     pMunch1 p = (:) <$$> p <**> pMunch p
[29;1H                     
[30;1H                     pOneOrMoreWithSep :: Parser a -> Parser b -> Parser [a]
[31;1H                     pOneOrMoreWithSep p sep = (:) <$$> p <**> pMunch (sep **> p)
[32;1H                     
[33;1H                     takeFirstParse :: [(a, [Token])] -> a
[34;1H                     takeFirstParse res = case res of
[35;1H                       (x, []) : _ 
[36;1H                         -> x
[37;1H                       (_, (i,_) : _): ps 
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     
[2;1H                     (<$$) :: a -> Parser b -> Parser a
[3;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[4;1H                     
[5;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[6;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[7;1H                                                        , (x, toks2) <- px toks1 ]
[8;1H                     
[9;1H                     (<**) :: Parser a -> Parser b -> Parser a
[10;1H                     p1 <** p2 = const <$$> p1 <**> p2
[11;1H                     
[12;1H                     (**>) :: Parser a -> Parser b -> Parser b
[13;1H                     p1 **> p2 = const id <$$> p1 <**> p2
[14;1H                     
[15;1H                     {-
[16;1H                     pThen  combine p1 p2 = combine <$$> p1 <**> p2
[17;1H                     pThen3 combine p1 p2 p3 = combine <$$> p1 <**> p2 <**> p3
[18;1H                     pThen4 combine p1 p2 p3 p4 = combine <$$> p1 <**> p2 <**> p3 <**> p4
[19;1H                     -}
[20;1H                     
[21;1H                     infixl 4 <$$>, <$$, <**>, <**, **>
[22;1H                     
[23;1H                     pMunch :: Parser a -> Parser [a]
[24;1H                     pMunch p = pMunch1 p `pAlt'` pEmpty []
[25;1H                     
[26;1H                     pMunch1 :: Parser a -> Parser [a]
[27;1H                     pMunch1 p = (:) <$$> p <**> pMunch p
[28;1H                     
[29;1H                     pOneOrMoreWithSep :: Parser a -> Parser b -> Parser [a]
[30;1H                     pOneOrMoreWithSep p sep = (:) <$$> p <**> pMunch (sep **> p)
[31;1H                     
[32;1H                     takeFirstParse :: [(a, [Token])] -> a
[33;1H                     takeFirstParse res = case res of
[34;1H                       (x, []) : _ 
[35;1H                         -> x
[36;1H                       (_, (i,_) : _): ps 
[37;1H                         -> case ps of
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     (<$$) :: a -> Parser b -> Parser a
[2;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[3;1H                     
[4;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[5;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[6;1H                                                        , (x, toks2) <- px toks1 ]
[7;1H                     
[8;1H                     (<**) :: Parser a -> Parser b -> Parser a
[9;1H                     p1 <** p2 = const <$$> p1 <**> p2
[10;1H                     
[11;1H                     (**>) :: Parser a -> Parser b -> Parser b
[12;1H                     p1 **> p2 = const id <$$> p1 <**> p2
[13;1H                     
[14;1H                     {-
[15;1H                     pThen  combine p1 p2 = combine <$$> p1 <**> p2
[16;1H                     pThen3 combine p1 p2 p3 = combine <$$> p1 <**> p2 <**> p3
[17;1H                     pThen4 combine p1 p2 p3 p4 = combine <$$> p1 <**> p2 <**> p3 <**> p4
[18;1H                     -}
[19;1H                     
[20;1H                     infixl 4 <$$>, <$$, <**>, <**, **>
[21;1H                     
[22;1H                     pMunch :: Parser a -> Parser [a]
[23;1H                     pMunch p = pMunch1 p `pAlt'` pEmpty []
[24;1H                     
[25;1H                     pMunch1 :: Parser a -> Parser [a]
[26;1H                     pMunch1 p = (:) <$$> p <**> pMunch p
[27;1H                     
[28;1H                     pOneOrMoreWithSep :: Parser a -> Parser b -> Parser [a]
[29;1H                     pOneOrMoreWithSep p sep = (:) <$$> p <**> pMunch (sep **> p)
[30;1H                     
[31;1H                     takeFirstParse :: [(a, [Token])] -> a
[32;1H                     takeFirstParse res = case res of
[33;1H                       (x, []) : _ 
[34;1H                         -> x
[35;1H                       (_, (i,_) : _): ps 
[36;1H                         -> case ps of
[37;1H                           _ : _ -> takeFirstParse ps
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     (x <$$ p) toks = [ (x, toks') | (_, toks') <- p toks ]
[2;1H                     
[3;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[4;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[5;1H                                                        , (x, toks2) <- px toks1 ]
[6;1H                     
[7;1H                     (<**) :: Parser a -> Parser b -> Parser a
[8;1H                     p1 <** p2 = const <$$> p1 <**> p2
[9;1H                     
[10;1H                     (**>) :: Parser a -> Parser b -> Parser b
[11;1H                     p1 **> p2 = const id <$$> p1 <**> p2
[12;1H                     
[13;1H                     {-
[14;1H                     pThen  combine p1 p2 = combine <$$> p1 <**> p2
[15;1H                     pThen3 combine p1 p2 p3 = combine <$$> p1 <**> p2 <**> p3
[16;1H                     pThen4 combine p1 p2 p3 p4 = combine <$$> p1 <**> p2 <**> p3 <**> p4
[17;1H                     -}
[18;1H                     
[19;1H                     infixl 4 <$$>, <$$, <**>, <**, **>
[20;1H                     
[21;1H                     pMunch :: Parser a -> Parser [a]
[22;1H                     pMunch p = pMunch1 p `pAlt'` pEmpty []
[23;1H                     
[24;1H                     pMunch1 :: Parser a -> Parser [a]
[25;1H                     pMunch1 p = (:) <$$> p <**> pMunch p
[26;1H                     
[27;1H                     pOneOrMoreWithSep :: Parser a -> Parser b -> Parser [a]
[28;1H                     pOneOrMoreWithSep p sep = (:) <$$> p <**> pMunch (sep **> p)
[29;1H                     
[30;1H                     takeFirstParse :: [(a, [Token])] -> a
[31;1H                     takeFirstParse res = case res of
[32;1H                       (x, []) : _ 
[33;1H                         -> x
[34;1H                       (_, (i,_) : _): ps 
[35;1H                         -> case ps of
[36;1H                           _ : _ -> takeFirstParse ps
[37;1H                           []    -> error $ "syntax error at line " ++ show i
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     
[2;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[3;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[4;1H                                                        , (x, toks2) <- px toks1 ]
[5;1H                     
[6;1H                     (<**) :: Parser a -> Parser b -> Parser a
[7;1H                     p1 <** p2 = const <$$> p1 <**> p2
[8;1H                     
[9;1H                     (**>) :: Parser a -> Parser b -> Parser b
[10;1H                     p1 **> p2 = const id <$$> p1 <**> p2
[11;1H                     
[12;1H                     {-
[13;1H                     pThen  combine p1 p2 = combine <$$> p1 <**> p2
[14;1H                     pThen3 combine p1 p2 p3 = combine <$$> p1 <**> p2 <**> p3
[15;1H                     pThen4 combine p1 p2 p3 p4 = combine <$$> p1 <**> p2 <**> p3 <**> p4
[16;1H                     -}
[17;1H                     
[18;1H                     infixl 4 <$$>, <$$, <**>, <**, **>
[19;1H                     
[20;1H                     pMunch :: Parser a -> Parser [a]
[21;1H                     pMunch p = pMunch1 p `pAlt'` pEmpty []
[22;1H                     
[23;1H                     pMunch1 :: Parser a -> Parser [a]
[24;1H                     pMunch1 p = (:) <$$> p <**> pMunch p
[25;1H                     
[26;1H                     pOneOrMoreWithSep :: Parser a -> Parser b -> Parser [a]
[27;1H                     pOneOrMoreWithSep p sep = (:) <$$> p <**> pMunch (sep **> p)
[28;1H                     
[29;1H                     takeFirstParse :: [(a, [Token])] -> a
[30;1H                     takeFirstParse res = case res of
[31;1H                       (x, []) : _ 
[32;1H                         -> x
[33;1H                       (_, (i,_) : _): ps 
[34;1H                         -> case ps of
[35;1H                           _ : _ -> takeFirstParse ps
[36;1H                           []    -> error $ "syntax error at line " ++ show i
[37;1H                       _ -> error  "syntax error at line 1"
[38;1H                     [K            :[K            [H[J                                                                                                                                                                                                                     [1;1H                     (<**>) :: Parser (a -> b) -> (Parser a -> Parser b)
[2;1H                     (pf <**> px) toks = [ (f x, toks2) | (f, toks1) <- pf toks
[3;1H                                                        , (x, toks2) <- px toks1 ]
[4;1H                     
[5;1H                     (<**) :: Parser a -> Parser b -> Parser a
[6;1H                     p1 <** p2 = const <$$> p1 <**> p2
[7;1H                     
[8;1H                     (**>) :: Parser a -> Parser b -> Parser b
[9;1H                     p1 **> p2 = const id <$$> p1 <**> p2
[10;1H                     
[11;1H                     {-
[12;1H                     pThen  combine p1 p2 = combine <$$> p1 <**> p2
[13;1H                     pThen3 combine p1 p2 p3 = combine <$$> p1 <**> p2 <**> p3
[14;1H                     pThen4 combine p1 p2 p3 p4 = combine <$$> p1 <**> p2 <**> p3 <**> p4
[15;1H                     -}
[16;1H                     
[17;1H                     infixl 4 <$$>, <$$, <**>, <**, **>
[18;1H                     
[19;1H                     pMunch :: Parser a -> Parser [a]
[20;1H                     pMunch p = pMunch1 p `pAlt'` pEmpty []
[21;1H                     
[22;1H                     pMunch1 :: Parser a -> Parser [a]
[23;1H                     pMunch1 p = (:) <$$> p <**> pMunch p
[24;1H                     
[25;1H                     pOneOrMoreWithSep :: Parser a -> Parser b -> Parser [a]
[26;1H                     pOneOrMoreWithSep p sep = (:) <$$> p <**> pMunch (sep **> p)
[27;1H                     
[28;1H                     takeFirstParse :: [(a, [Token])] -> a
[29;1H                     takeFirstParse res = case res of
[30;1H                       (x, []) : _ 
[31;1H                         -> x
[32;1H                       (_, (i,_) : _): ps 
[33;1H                         -> case ps of
[34;1H                           _ : _ -> takeFirstParse ps
[35;1H                           []    -> error $ "syntax error at line " ++ show i
[36;1H                       _ -> error  "syntax error at line 1"
[37;1H                       [38;1H                     [K            :[K            [38;1H                     [K            [7m        (END)[m        :[K            [38;1H                     [K            [7m        (END)[m        :[K            [?1l>[38;1H                     
[1m[7m%[27m[1m[0m                                                                                 [0m[27m[24m[J[4mλ.[24m [K[51C[36mfeature[39m: [4m~/devel/pointfree[24m[77D[?1h=[?2004hmore ../ifl-tut/src/Parser.hs[29Dlghci src/Expr.hs            [12D[?1l>[?2004l
GHCi, version 9.2.7: https://www.haskell.org/ghc/  :? for help
Some flags have not been recognized: -XOverloadedRecordDots
Loaded GHCi configuration from /home/nobsun/Dropbox/devel/pointfree/.ghci
[1 of 1] Compiling Expr             ( src/Expr.hs, interpreted )

[;1msrc/Expr.hs:111:33: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m
    • Variable not in scope: pAExpr :: ReadP Expr
    • Perhaps you meant one of these:
        ‘pExpr’ (line 102), ‘pprExpr’ (line 54), ‘pExpr1’ (line 105)[0m[0m
[;1m[34m    |[0m[0m
[;1m[34m111 |[0m[0m pExpr2 = foldl1 EAp <$> pMunch1 [;1m[31mpAExpr[0m[0m
[;1m[34m    |[0m[0m[;1m[31m                                 ^^^^^^[0m[0m
Failed, no modules loaded.
2023-05-17 13:50:00.301533274
[?1h=>>> :rE[?1l>   1    module Expr where
   2    
   3    import Data.Bool
   4    import Data.Char
   5    import Data.List (nub)
   6    import Data.Functor.Foldable
   7    import Text.ParserCombinators.ReadP
   8    import Text.PrettyPrint (Doc, (<+>))
   9    import qualified Text.PrettyPrint as PP
  10    
  11    type Name = String
  12    
  13    data Expr
  14        = EVar Name
  15        | ENum Int
  16        | EAp Expr Expr
  17        deriving (Eq)
  18    
  19    isAtom :: Expr -> Bool
  20    isAtom = \ case
  21        EAp _ _ -> False
  22        _       -> True
  23    
  24    data ExprF r
  25        = EVarF Name
  26        | ENumF Int
  27        | EApF r r
  28        deriving (Functor)
  29    
  30    type instance Base Expr = ExprF
  31    
  32    instance Recursive Expr where
  33        project = \ case
  34            EVar v -> EVarF v
  35            ENum n -> ENumF n
  36            EAp s t -> EApF s t
  37    
  38    instance Corecursive Expr where
  39        embed = \ case
  40            EVarF v  -> EVar v
  41            ENumF n  -> ENum n
  42            EApF s t -> EAp s t
  43    
  44    type ScDefn = (Name, [Name], Expr)
  45    
  46    -- Pretty Printer
  47    
  48    pprScDefn :: ScDefn -> PP.Doc
  49    pprScDefn = \ case
  50        (name, vars, expr)
  51            -> PP.text name <+> PP.hsep (map PP.text vars) <+> PP.text "=" <+> pprExpr expr
  52    
  53    pprExpr :: Expr -> PP.Doc
  54    pprExpr = \ case
  55        EVar v  -> PP.text v
  56        ENum n  -> PP.int n
  57        EAp s t -> case s of
  58            ENum _  -> error "number is not a function."
  59            EVar v' -> PP.text v' <+> pprExpr' t
  60            EAp (EVar o) s'
  61                | isInfix o -> pprExpr' s' <+> PP.text o <+> pprExpr' t
  62                | otherwise -> PP.text o <+> pprExpr' s' <+> pprExpr' t
  63            EAp f s'        -> pprExpr f <+> pprExpr' s' <+> pprExpr' t
  64    
  65    pprExpr' :: Expr -> PP.Doc
  66    pprExpr' = \ case
  67        EVar o
  68            | isInfix o -> PP.parens (PP.text o)
  69            | otherwise -> PP.text o
  70        ENum n          -> PP.int n
  71        e               -> PP.parens (pprExpr e)
  72    
  73    isInfix :: String -> Bool
  74    isInfix = all  (`elem` symbols)
  75    
  76    symbols :: String
  77    symbols = ".<>+-*/&|#%^="
  78    
  79    instance Show Expr where
  80        show = PP.render . pprExpr
  81    
  82    -- Parser
  83    
  84    parse :: ReadP a -> ReadS a
  85    parse = readP_to_S
  86    
  87    token :: ReadP a -> ReadP a
  88    token = (skipSpaces *>)
  89    
  90    pMunch :: ReadP a -> ReadP [a]
  91    pMunch p = pMunch1 p <++ pure []
  92    
  93    pMunch1 :: ReadP a -> ReadP [a]
  94    pMunch1 p = (:) <$> p <*> pMunch p
  95    
  96    --
  97    
  98    pBop :: Name -> ReadP (Expr -> Expr -> Expr)
  99    pBop op = (EAp .) . (EAp . EVar) <$> (token (string op))
 100    
 101    pExpr :: ReadP Expr
 102    pExpr = chainr1 pExpr1 (pBop "||")
 103    
 104    pExpr1 :: ReadP Expr
 105    pExpr1 = chainr1 pExpr2 (pBop "&&")
 106    
 107    mkBop :: Expr -> Name -> Expr -> Expr
 108    mkBop e1 o e2 = EAp (EAp (EVar o) e1) e2
 109    
 110    pExpr2 :: ReadP Expr
 111    pExpr2 = foldl1 EAp <$> pMunch1 pAExpr
 112    
 113    pAExpr :: ReadP Expr
 114    pAExpr = pENum +++ pEVar +++ parens pExpr
 115    
 116    relops :: [String]
 117    relops = [ "<"
 118             , "<="
 119             , ">="
 120             , ">"
 121             , "=="
 122             , "/="
 123             ]
 124    
[1 of 1] Compiling Expr             ( src/Expr.hs, interpreted )

[;1msrc/Expr.hs:114:10: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m
    • Variable not in scope: pENum :: ReadP Expr
    • Perhaps you meant data constructor ‘ENum’ (line 15)[0m[0m
[;1m[34m    |[0m[0m
[;1m[34m114 |[0m[0m pAExpr = [;1m[31mpENum[0m[0m +++ pEVar +++ parens pExpr
[;1m[34m    |[0m[0m[;1m[31m          ^^^^^[0m[0m

[;1msrc/Expr.hs:114:20: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m
    • Variable not in scope: pEVar :: ReadP Expr
    • Perhaps you meant data constructor ‘EVar’ (line 14)[0m[0m
[;1m[34m    |[0m[0m
[;1m[34m114 |[0m[0m pAExpr = pENum +++ [;1m[31mpEVar[0m[0m +++ parens pExpr
[;1m[34m    |[0m[0m[;1m[31m                    ^^^^^[0m[0m

[;1msrc/Expr.hs:114:30: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m
    • Variable not in scope: parens :: ReadP Expr -> ReadP Expr
    • Perhaps you meant one of these:
        ‘PP.parens’ (imported from Text.PrettyPrint),
        ‘PP.lparen’ (imported from Text.PrettyPrint),
        ‘PP.rparen’ (imported from Text.PrettyPrint)
      Perhaps you want to add ‘parens’ to the import list
      in the import of ‘Text.PrettyPrint’ (src/Expr.hs:8:1-36).[0m[0m
[;1m[34m    |[0m[0m
[;1m[34m114 |[0m[0m pAExpr = pENum +++ pEVar +++ [;1m[31mparens[0m[0m pExpr
[;1m[34m    |[0m[0m[;1m[31m                              ^^^^^^[0m[0m
Failed, no modules loaded.
2023-05-17 13:52:07.598950443
[?1h=>>> :q[KrE[?1l>   1    module Expr where
   2    
   3    import Data.Bool
   4    import Data.Char
   5    import Data.List (nub)
   6    import Data.Functor.Foldable
   7    import Text.ParserCombinators.ReadP
   8    import Text.PrettyPrint (Doc, (<+>))
   9    import qualified Text.PrettyPrint as PP
  10    
  11    type Name = String
  12    
  13    data Expr
  14        = EVar Name
  15        | ENum Int
  16        | EAp Expr Expr
  17        deriving (Eq)
  18    
  19    isAtom :: Expr -> Bool
  20    isAtom = \ case
  21        EAp _ _ -> False
  22        _       -> True
  23    
  24    data ExprF r
  25        = EVarF Name
  26        | ENumF Int
  27        | EApF r r
  28        deriving (Functor)
  29    
  30    type instance Base Expr = ExprF
  31    
  32    instance Recursive Expr where
  33        project = \ case
  34            EVar v -> EVarF v
  35            ENum n -> ENumF n
  36            EAp s t -> EApF s t
  37    
  38    instance Corecursive Expr where
  39        embed = \ case
  40            EVarF v  -> EVar v
  41            ENumF n  -> ENum n
  42            EApF s t -> EAp s t
  43    
  44    type ScDefn = (Name, [Name], Expr)
  45    
  46    -- Pretty Printer
  47    
  48    pprScDefn :: ScDefn -> PP.Doc
  49    pprScDefn = \ case
  50        (name, vars, expr)
  51            -> PP.text name <+> PP.hsep (map PP.text vars) <+> PP.text "=" <+> pprExpr expr
  52    
  53    pprExpr :: Expr -> PP.Doc
  54    pprExpr = \ case
  55        EVar v  -> PP.text v
  56        ENum n  -> PP.int n
  57        EAp s t -> case s of
  58            ENum _  -> error "number is not a function."
  59            EVar v' -> PP.text v' <+> pprExpr' t
  60            EAp (EVar o) s'
  61                | isInfix o -> pprExpr' s' <+> PP.text o <+> pprExpr' t
  62                | otherwise -> PP.text o <+> pprExpr' s' <+> pprExpr' t
  63            EAp f s'        -> pprExpr f <+> pprExpr' s' <+> pprExpr' t
  64    
  65    pprExpr' :: Expr -> PP.Doc
  66    pprExpr' = \ case
  67        EVar o
  68            | isInfix o -> PP.parens (PP.text o)
  69            | otherwise -> PP.text o
  70        ENum n          -> PP.int n
  71        e               -> PP.parens (pprExpr e)
  72    
  73    isInfix :: String -> Bool
  74    isInfix = all  (`elem` symbols)
  75    
  76    symbols :: String
  77    symbols = ".<>+-*/&|#%^="
  78    
  79    instance Show Expr where
  80        show = PP.render . pprExpr
  81    
  82    -- Parser
  83    
  84    parse :: ReadP a -> ReadS a
  85    parse = readP_to_S
  86    
  87    token :: ReadP a -> ReadP a
  88    token = (skipSpaces *>)
  89    
  90    pMunch :: ReadP a -> ReadP [a]
  91    pMunch p = pMunch1 p <++ pure []
  92    
  93    pMunch1 :: ReadP a -> ReadP [a]
  94    pMunch1 p = (:) <$> p <*> pMunch p
  95    
  96    isIdent :: Char -> Bool
  97    isIdent c = isAlpha
  98    
  99    --
 100    
 101    pBop :: Name -> ReadP (Expr -> Expr -> Expr)
 102    pBop op = (EAp .) . (EAp . EVar) <$> (token (string op))
 103    
 104    pExpr :: ReadP Expr
 105    pExpr = chainr1 pExpr1 (pBop "||")
 106    
 107    pExpr1 :: ReadP Expr
 108    pExpr1 = chainr1 pExpr2 (pBop "&&")
 109    
 110    mkBop :: Expr -> Name -> Expr -> Expr
 111    mkBop e1 o e2 = EAp (EAp (EVar o) e1) e2
 112    
 113    pExpr2 :: ReadP Expr
 114    pExpr2 = foldl1 EAp <$> pMunch1 pAExpr
 115    
 116    pAExpr :: ReadP Expr
 117    pAExpr = pENum +++ pEVar +++ parens pExpr
 118    
 119    pENum :: ReadP Expr
 120    pENum = token (ENum . read <$> munch1 isDigit)
 121    
 122    pEVar :: ReadP Expr
 123    pEVar = token (EVar <$> ((:) <$> satisfy isAlpha <$> munch isAlphaNum))
 124    
 125    
 126    test :: String
 127    test = "True && False && True"
 128    
 129    relops :: [String]
 130    relops = [ "<"
 131             , "<="
 132             , ">="
 133             , ">"
 134             , "=="
 135             , "/="
 136             ]
 137    
[1 of 1] Compiling Expr             ( src/Expr.hs, interpreted )

[;1msrc/Expr.hs:117:30: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m
    • Variable not in scope: parens :: ReadP Expr -> ReadP Expr
    • Perhaps you meant one of these:
        ‘PP.parens’ (imported from Text.PrettyPrint),
        ‘PP.lparen’ (imported from Text.PrettyPrint),
        ‘PP.rparen’ (imported from Text.PrettyPrint)
      Perhaps you want to add ‘parens’ to the import list
      in the import of ‘Text.PrettyPrint’ (src/Expr.hs:8:1-36).[0m[0m
[;1m[34m    |[0m[0m
[;1m[34m117 |[0m[0m pAExpr = pENum +++ pEVar +++ [;1m[31mparens[0m[0m pExpr
[;1m[34m    |[0m[0m[;1m[31m                              ^^^^^^[0m[0m
Failed, no modules loaded.
2023-05-17 14:03:57.360033223
[?1h=>>> :rE[?1l>   1    module Expr where
   2    
   3    import Data.Bool
   4    import Data.Char
   5    import Data.List (nub)
   6    import Data.Functor.Foldable
   7    import Text.ParserCombinators.ReadP
   8    import Text.PrettyPrint (Doc, (<+>))
   9    import qualified Text.PrettyPrint as PP
  10    
  11    type Name = String
  12    
  13    data Expr
  14        = EVar Name
  15        | ENum Int
  16        | EAp Expr Expr
  17        deriving (Eq)
  18    
  19    isAtom :: Expr -> Bool
  20    isAtom = \ case
  21        EAp _ _ -> False
  22        _       -> True
  23    
  24    data ExprF r
  25        = EVarF Name
  26        | ENumF Int
  27        | EApF r r
  28        deriving (Functor)
  29    
  30    type instance Base Expr = ExprF
  31    
  32    instance Recursive Expr where
  33        project = \ case
  34            EVar v -> EVarF v
  35            ENum n -> ENumF n
  36            EAp s t -> EApF s t
  37    
  38    instance Corecursive Expr where
  39        embed = \ case
  40            EVarF v  -> EVar v
  41            ENumF n  -> ENum n
  42            EApF s t -> EAp s t
  43    
  44    type ScDefn = (Name, [Name], Expr)
  45    
  46    -- Pretty Printer
  47    
  48    pprScDefn :: ScDefn -> PP.Doc
  49    pprScDefn = \ case
  50        (name, vars, expr)
  51            -> PP.text name <+> PP.hsep (map PP.text vars) <+> PP.text "=" <+> pprExpr expr
  52    
  53    pprExpr :: Expr -> PP.Doc
  54    pprExpr = \ case
  55        EVar v  -> PP.text v
  56        ENum n  -> PP.int n
  57        EAp s t -> case s of
  58            ENum _  -> error "number is not a function."
  59            EVar v' -> PP.text v' <+> pprExpr' t
  60            EAp (EVar o) s'
  61                | isInfix o -> pprExpr' s' <+> PP.text o <+> pprExpr' t
  62                | otherwise -> PP.text o <+> pprExpr' s' <+> pprExpr' t
  63            EAp f s'        -> pprExpr f <+> pprExpr' s' <+> pprExpr' t
  64    
  65    pprExpr' :: Expr -> PP.Doc
  66    pprExpr' = \ case
  67        EVar o
  68            | isInfix o -> PP.parens (PP.text o)
  69            | otherwise -> PP.text o
  70        ENum n          -> PP.int n
  71        e               -> PP.parens (pprExpr e)
  72    
  73    isInfix :: String -> Bool
  74    isInfix = all  (`elem` symbols)
  75    
  76    symbols :: String
  77    symbols = ".<>+-*/&|#%^="
  78    
  79    instance Show Expr where
  80        show = PP.render . pprExpr
  81    
  82    -- Parser
  83    
  84    parse :: ReadP a -> ReadS a
  85    parse = readP_to_S
  86    
  87    token :: ReadP a -> ReadP a
  88    token = (skipSpaces *>)
  89    
  90    pMunch :: ReadP a -> ReadP [a]
  91    pMunch p = pMunch1 p <++ pure []
  92    
  93    pMunch1 :: ReadP a -> ReadP [a]
  94    pMunch1 p = (:) <$> p <*> pMunch p
  95    
  96    isIdent :: Char -> Bool
  97    isIdent c = isAlpha
  98    
  99    --
 100    
 101    pBop :: Name -> ReadP (Expr -> Expr -> Expr)
 102    pBop op = (EAp .) . (EAp . EVar) <$> (token (string op))
 103    
 104    pExpr :: ReadP Expr
 105    pExpr = chainr1 pExpr1 (pBop "||")
 106    
 107    pExpr1 :: ReadP Expr
 108    pExpr1 = chainr1 pExpr2 (pBop "&&")
 109    
 110    mkBop :: Expr -> Name -> Expr -> Expr
 111    mkBop e1 o e2 = EAp (EAp (EVar o) e1) e2
 112    
 113    pExpr2 :: ReadP Expr
 114    pExpr2 = foldl1 EAp <$> pMunch1 pAExpr
 115    
 116    pAExpr :: ReadP Expr
 117    pAExpr = pENum +++ pEVar +++ between (char '(') (char ')') pExpr
 118    
 119    pENum :: ReadP Expr
 120    pENum = token (ENum . read <$> munch1 isDigit)
 121    
 122    pEVar :: ReadP Expr
 123    pEVar = token (EVar <$> ((:) <$> satisfy isAlpha <$> munch isAlphaNum))
 124    
 125    test :: String
 126    test = "True && False && True"
 127    
 128    relops :: [String]
 129    relops = [ "<"
 130             , "<="
 131             , ">="
 132             , ">"
 133             , "=="
 134             , "/="
 135             ]
 136    
[1 of 1] Compiling Expr             ( src/Expr.hs, interpreted )

[;1msrc/Expr.hs:97:13: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m
    • Couldn't match expected type ‘Bool’
                  with actual type ‘Char -> Bool’
    • Probable cause: ‘isAlpha’ is applied to too few arguments
      In the expression: isAlpha
      In an equation for ‘isIdent’: isIdent c = isAlpha[0m[0m
[;1m[34m   |[0m[0m
[;1m[34m97 |[0m[0m isIdent c = [;1m[31misAlpha[0m[0m
[;1m[34m   |[0m[0m[;1m[31m             ^^^^^^^[0m[0m

[;1msrc/Expr.hs:123:26: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m
    • Couldn't match expected type: String -> Name
                  with actual type: ReadP ([Char] -> [Char])
    • Possible cause: ‘(<$>)’ is applied to too many arguments
      In the first argument of ‘(<$>)’, namely ‘(:) <$> satisfy isAlpha’
      In the second argument of ‘(<$>)’, namely
        ‘((:) <$> satisfy isAlpha <$> munch isAlphaNum)’
      In the first argument of ‘token’, namely
        ‘(EVar <$> ((:) <$> satisfy isAlpha <$> munch isAlphaNum))’[0m[0m
[;1m[34m    |[0m[0m
[;1m[34m123 |[0m[0m pEVar = token (EVar <$> ([;1m[31m(:) <$> satisfy isAlpha[0m[0m <$> munch isAlphaNum))
[;1m[34m    |[0m[0m[;1m[31m                          ^^^^^^^^^^^^^^^^^^^^^^^[0m[0m
Failed, no modules loaded.
2023-05-17 14:05:43.796502259
[?1h=>>> :t satisp[KfyE[?1l>
[;1m<interactive>:1:1: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m Variable not in scope: satisfy[0m[0m
2023-05-17 14:06:53.895561202
[?1h=>>> :rE[?1l>   1    module Expr where
   2    
   3    import Data.Bool
   4    import Data.Char
   5    import Data.List (nub)
   6    import Data.Functor.Foldable
   7    import Text.ParserCombinators.ReadP
   8    import Text.PrettyPrint (Doc, (<+>))
   9    import qualified Text.PrettyPrint as PP
  10    
  11    type Name = String
  12    
  13    data Expr
  14        = EVar Name
  15        | ENum Int
  16        | EAp Expr Expr
  17        deriving (Eq)
  18    
  19    isAtom :: Expr -> Bool
  20    isAtom = \ case
  21        EAp _ _ -> False
  22        _       -> True
  23    
  24    data ExprF r
  25        = EVarF Name
  26        | ENumF Int
  27        | EApF r r
  28        deriving (Functor)
  29    
  30    type instance Base Expr = ExprF
  31    
  32    instance Recursive Expr where
  33        project = \ case
  34            EVar v -> EVarF v
  35            ENum n -> ENumF n
  36            EAp s t -> EApF s t
  37    
  38    instance Corecursive Expr where
  39        embed = \ case
  40            EVarF v  -> EVar v
  41            ENumF n  -> ENum n
  42            EApF s t -> EAp s t
  43    
  44    type ScDefn = (Name, [Name], Expr)
  45    
  46    -- Pretty Printer
  47    
  48    pprScDefn :: ScDefn -> PP.Doc
  49    pprScDefn = \ case
  50        (name, vars, expr)
  51            -> PP.text name <+> PP.hsep (map PP.text vars) <+> PP.text "=" <+> pprExpr expr
  52    
  53    pprExpr :: Expr -> PP.Doc
  54    pprExpr = \ case
  55        EVar v  -> PP.text v
  56        ENum n  -> PP.int n
  57        EAp s t -> case s of
  58            ENum _  -> error "number is not a function."
  59            EVar v' -> PP.text v' <+> pprExpr' t
  60            EAp (EVar o) s'
  61                | isInfix o -> pprExpr' s' <+> PP.text o <+> pprExpr' t
  62                | otherwise -> PP.text o <+> pprExpr' s' <+> pprExpr' t
  63            EAp f s'        -> pprExpr f <+> pprExpr' s' <+> pprExpr' t
  64    
  65    pprExpr' :: Expr -> PP.Doc
  66    pprExpr' = \ case
  67        EVar o
  68            | isInfix o -> PP.parens (PP.text o)
  69            | otherwise -> PP.text o
  70        ENum n          -> PP.int n
  71        e               -> PP.parens (pprExpr e)
  72    
  73    isInfix :: String -> Bool
  74    isInfix = all  (`elem` symbols)
  75    
  76    symbols :: String
  77    symbols = ".<>+-*/&|#%^="
  78    
  79    instance Show Expr where
  80        show = PP.render . pprExpr
  81    
  82    -- Parser
  83    
  84    parse :: ReadP a -> ReadS a
  85    parse = readP_to_S
  86    
  87    token :: ReadP a -> ReadP a
  88    token = (skipSpaces *>)
  89    
  90    pMunch :: ReadP a -> ReadP [a]
  91    pMunch p = pMunch1 p <++ pure []
  92    
  93    pMunch1 :: ReadP a -> ReadP [a]
  94    pMunch1 p = (:) <$> p <*> pMunch p
  95    
  96    isIdent :: Char -> Bool
  97    isIdent c = isAlpha
  98    
  99    --
 100    
 101    pBop :: Name -> ReadP (Expr -> Expr -> Expr)
 102    pBop op = (EAp .) . (EAp . EVar) <$> (token (string op))
 103    
 104    pExpr :: ReadP Expr
 105    pExpr = chainr1 pExpr1 (pBop "||")
 106    
 107    pExpr1 :: ReadP Expr
 108    pExpr1 = chainr1 pExpr2 (pBop "&&")
 109    
 110    mkBop :: Expr -> Name -> Expr -> Expr
 111    mkBop e1 o e2 = EAp (EAp (EVar o) e1) e2
 112    
 113    pExpr2 :: ReadP Expr
 114    pExpr2 = foldl1 EAp <$> pMunch1 pAExpr
 115    
 116    pAExpr :: ReadP Expr
 117    pAExpr = pENum +++ pEVar +++ between (char '(') (char ')') pExpr
 118    
 119    pENum :: ReadP Expr
 120    pENum = token (ENum . read <$> munch1 isDigit)
 121    
 122    pEVar :: ReadP Expr
 123    pEVar = token (EVar <$> ((:) <$> satisfy isAlpha <*> munch isAlphaNum))
 124    
 125    test :: String
 126    test = "True && False && True"
 127    
 128    relops :: [String]
 129    relops = [ "<"
 130             , "<="
 131             , ">="
 132             , ">"
 133             , "=="
 134             , "/="
 135             ]
 136    
[1 of 1] Compiling Expr             ( src/Expr.hs, interpreted )

[;1msrc/Expr.hs:97:13: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m
    • Couldn't match expected type ‘Bool’
                  with actual type ‘Char -> Bool’
    • Probable cause: ‘isAlpha’ is applied to too few arguments
      In the expression: isAlpha
      In an equation for ‘isIdent’: isIdent c = isAlpha[0m[0m
[;1m[34m   |[0m[0m
[;1m[34m97 |[0m[0m isIdent c = [;1m[31misAlpha[0m[0m
[;1m[34m   |[0m[0m[;1m[31m             ^^^^^^^[0m[0m
Failed, no modules loaded.
2023-05-17 14:10:06.755439796
[?1h=>>> :rE[?1l>   1    module Expr where
   2    
   3    import Data.Bool
   4    import Data.Char
   5    import Data.List (nub)
   6    import Data.Functor.Foldable
   7    import Text.ParserCombinators.ReadP
   8    import Text.PrettyPrint (Doc, (<+>))
   9    import qualified Text.PrettyPrint as PP
  10    
  11    type Name = String
  12    
  13    data Expr
  14        = EVar Name
  15        | ENum Int
  16        | EAp Expr Expr
  17        deriving (Eq)
  18    
  19    isAtom :: Expr -> Bool
  20    isAtom = \ case
  21        EAp _ _ -> False
  22        _       -> True
  23    
  24    data ExprF r
  25        = EVarF Name
  26        | ENumF Int
  27        | EApF r r
  28        deriving (Functor)
  29    
  30    type instance Base Expr = ExprF
  31    
  32    instance Recursive Expr where
  33        project = \ case
  34            EVar v -> EVarF v
  35            ENum n -> ENumF n
  36            EAp s t -> EApF s t
  37    
  38    instance Corecursive Expr where
  39        embed = \ case
  40            EVarF v  -> EVar v
  41            ENumF n  -> ENum n
  42            EApF s t -> EAp s t
  43    
  44    type ScDefn = (Name, [Name], Expr)
  45    
  46    -- Pretty Printer
  47    
  48    pprScDefn :: ScDefn -> PP.Doc
  49    pprScDefn = \ case
  50        (name, vars, expr)
  51            -> PP.text name <+> PP.hsep (map PP.text vars) <+> PP.text "=" <+> pprExpr expr
  52    
  53    pprExpr :: Expr -> PP.Doc
  54    pprExpr = \ case
  55        EVar v  -> PP.text v
  56        ENum n  -> PP.int n
  57        EAp s t -> case s of
  58            ENum _  -> error "number is not a function."
  59            EVar v' -> PP.text v' <+> pprExpr' t
  60            EAp (EVar o) s'
  61                | isInfix o -> pprExpr' s' <+> PP.text o <+> pprExpr' t
  62                | otherwise -> PP.text o <+> pprExpr' s' <+> pprExpr' t
  63            EAp f s'        -> pprExpr f <+> pprExpr' s' <+> pprExpr' t
  64    
  65    pprExpr' :: Expr -> PP.Doc
  66    pprExpr' = \ case
  67        EVar o
  68            | isInfix o -> PP.parens (PP.text o)
  69            | otherwise -> PP.text o
  70        ENum n          -> PP.int n
  71        e               -> PP.parens (pprExpr e)
  72    
  73    isInfix :: String -> Bool
  74    isInfix = all  (`elem` symbols)
  75    
  76    symbols :: String
  77    symbols = ".<>+-*/&|#%^="
  78    
  79    instance Show Expr where
  80        show = PP.render . pprExpr
  81    
  82    -- Parser
  83    
  84    parse :: ReadP a -> ReadS a
  85    parse = readP_to_S
  86    
  87    token :: ReadP a -> ReadP a
  88    token = (skipSpaces *>)
  89    
  90    pMunch :: ReadP a -> ReadP [a]
  91    pMunch p = pMunch1 p <++ pure []
  92    
  93    pMunch1 :: ReadP a -> ReadP [a]
  94    pMunch1 p = (:) <$> p <*> pMunch p
  95    
  96    --
  97    
  98    pBop :: Name -> ReadP (Expr -> Expr -> Expr)
  99    pBop op = (EAp .) . (EAp . EVar) <$> (token (string op))
 100    
 101    pExpr :: ReadP Expr
 102    pExpr = chainr1 pExpr1 (pBop "||")
 103    
 104    pExpr1 :: ReadP Expr
 105    pExpr1 = chainr1 pExpr2 (pBop "&&")
 106    
 107    mkBop :: Expr -> Name -> Expr -> Expr
 108    mkBop e1 o e2 = EAp (EAp (EVar o) e1) e2
 109    
 110    pExpr2 :: ReadP Expr
 111    pExpr2 = foldl1 EAp <$> pMunch1 pAExpr
 112    
 113    pAExpr :: ReadP Expr
 114    pAExpr = pENum +++ pEVar +++ between (char '(') (char ')') pExpr
 115    
 116    pENum :: ReadP Expr
 117    pENum = token (ENum . read <$> munch1 isDigit)
 118    
 119    pEVar :: ReadP Expr
 120    pEVar = token (EVar <$> ((:) <$> satisfy isAlpha <*> munch isAlphaNum))
 121    
 122    test :: String
 123    test = "True && False && True"
 124    
 125    relops :: [String]
 126    relops = [ "<"
 127             , "<="
 128             , ">="
 129             , ">"
 130             , "=="
 131             , "/="
 132             ]
 133    
[1 of 1] Compiling Expr             ( src/Expr.hs, interpreted )
Ok, one module loaded.
2023-05-17 14:10:30.02706228
[?1h=>>> parse testE[?1l>
[;1m<interactive>:7:7: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m
    • Couldn't match type: [Char]
                     with: ReadP a
      Expected: ReadP a
        Actual: String
    • In the first argument of ‘parse’, namely ‘test’
      In the expression: parse test
      In an equation for ‘it’: it = parse test
    • Relevant bindings include
        it :: ReadS a (bound at <interactive>:7:1)[0m[0m
2023-05-17 14:10:37.909039227
[?1h=>>> parse testptest[4DEtest[4Dxtest[4Dptest[4Drtest[4D test[4DE[?1l>[(True," && False && True"),(True && False," && True"),(True && (False && True),"")]
2023-05-17 14:11:34.617925151
[?1h=>>> :rE[?1l>   1    module Expr where
   2    
   3    import Data.Bool
   4    import Data.Char
   5    import Data.List (nub)
   6    import Data.Functor.Foldable
   7    import Text.ParserCombinators.ReadP
   8    import Text.PrettyPrint (Doc, (<+>))
   9    import qualified Text.PrettyPrint as PP
  10    
  11    type Name = String
  12    
  13    data Expr
  14        = EVar Name
  15        | ENum Int
  16        | EAp Expr Expr
  17        deriving (Eq)
  18    
  19    isAtom :: Expr -> Bool
  20    isAtom = \ case
  21        EAp _ _ -> False
  22        _       -> True
  23    
  24    data ExprF r
  25        = EVarF Name
  26        | ENumF Int
  27        | EApF r r
  28        deriving (Functor)
  29    
  30    type instance Base Expr = ExprF
  31    
  32    instance Recursive Expr where
  33        project = \ case
  34            EVar v -> EVarF v
  35            ENum n -> ENumF n
  36            EAp s t -> EApF s t
  37    
  38    instance Corecursive Expr where
  39        embed = \ case
  40            EVarF v  -> EVar v
  41            ENumF n  -> ENum n
  42            EApF s t -> EAp s t
  43    
  44    type ScDefn = (Name, [Name], Expr)
  45    
  46    -- Pretty Printer
  47    
  48    pprScDefn :: ScDefn -> PP.Doc
  49    pprScDefn = \ case
  50        (name, vars, expr)
  51            -> PP.text name <+> PP.hsep (map PP.text vars) <+> PP.text "=" <+> pprExpr expr
  52    
  53    pprExpr :: Expr -> PP.Doc
  54    pprExpr = \ case
  55        EVar v  -> PP.text v
  56        ENum n  -> PP.int n
  57        EAp s t -> case s of
  58            ENum _  -> error "number is not a function."
  59            EVar v' -> PP.text v' <+> pprExpr' t
  60            EAp (EVar o) s'
  61                | isInfix o -> pprExpr' s' <+> PP.text o <+> pprExpr' t
  62                | otherwise -> PP.text o <+> pprExpr' s' <+> pprExpr' t
  63            EAp f s'        -> pprExpr f <+> pprExpr' s' <+> pprExpr' t
  64    
  65    pprExpr' :: Expr -> PP.Doc
  66    pprExpr' = \ case
  67        EVar o
  68            | isInfix o -> PP.parens (PP.text o)
  69            | otherwise -> PP.text o
  70        ENum n          -> PP.int n
  71        e               -> PP.parens (pprExpr e)
  72    
  73    isInfix :: String -> Bool
  74    isInfix = all  (`elem` symbols)
  75    
  76    symbols :: String
  77    symbols = ".<>+-*/&|#%^="
  78    
  79    instance Show Expr where
  80        show = PP.render . pprExpr
  81    
  82    -- Parser
  83    
  84    parse :: ReadP a -> ReadS a
  85    parse = readP_to_S
  86    
  87    token :: ReadP a -> ReadP a
  88    token = (skipSpaces *>)
  89    
  90    pMunch :: ReadP a -> ReadP [a]
  91    pMunch p = pMunch1 p <++ pure []
  92    
  93    pMunch1 :: ReadP a -> ReadP [a]
  94    pMunch1 p = (:) <$> p <*> pMunch p
  95    
  96    --
  97    
  98    pBop :: Name -> ReadP (Expr -> Expr -> Expr)
  99    pBop op = (EAp .) . (EAp . EVar) <$> (token (string op))
 100    
 101    pExpr :: ReadP Expr
 102    pExpr = chainr1 pExpr1 (pBop "||")
 103    
 104    pExpr1 :: ReadP Expr
 105    pExpr1 = chainr1 pExpr2 (pBop "&&")
 106    
 107    mkBop :: Expr -> Name -> Expr -> Expr
 108    mkBop e1 o e2 = EAp (EAp (EVar o) e1) e2
 109    
 110    pExpr2 :: ReadP Expr
 111    pExpr2 = foldl1 EAp <$> pMunch1 pAExpr
 112    
 113    pAExpr :: ReadP Expr
 114    pAExpr = pENum +++ pEVar +++ between (char '(') (char ')') pExpr
 115    
 116    pENum :: ReadP Expr
 117    pENum = token (ENum . read <$> munch1 isDigit)
 118    
 119    pEVar :: ReadP Expr
 120    pEVar = token (EVar <$> ((:) <$> satisfy isAlpha <*> munch isAlphaNum))
 121    
 122    test :: String
 123    test = "True && False && True"
 124    
 125    relops :: [String]
 126    relops = [ "<"
 127             , "<="
 128             , ">="
 129             , ">"
 130             , "=="
 131             , "/="
 132             ]
 133    
 134    instance Read Expr where
 135        readsPrec _ = readP_to_S pExpr
[1 of 1] Compiling Expr             ( src/Expr.hs, interpreted )
Ok, one module loaded.
2023-05-17 14:31:46.722793552
[?1h=>>> read @Expr testE[?1l>True && (False && True)
2023-05-17 14:32:01.704118117
[?1h=>>> read @Expr test[15D:r[KE[?1l>   1    module Expr where
   2    
   3    import Data.Bool
   4    import Data.Char
   5    import Data.List (nub)
   6    import Data.Functor.Foldable
   7    import Text.ParserCombinators.ReadP
   8    import Text.PrettyPrint (Doc, (<+>))
   9    import qualified Text.PrettyPrint as PP
  10    
  11    type Name = String
  12    
  13    data Expr
  14        = EVar Name
  15        | ENum Int
  16        | EAp Expr Expr
  17        deriving (Eq)
  18    
  19    isAtom :: Expr -> Bool
  20    isAtom = \ case
  21        EAp _ _ -> False
  22        _       -> True
  23    
  24    data ExprF r
  25        = EVarF Name
  26        | ENumF Int
  27        | EApF r r
  28        deriving (Functor)
  29    
  30    type instance Base Expr = ExprF
  31    
  32    instance Recursive Expr where
  33        project = \ case
  34            EVar v -> EVarF v
  35            ENum n -> ENumF n
  36            EAp s t -> EApF s t
  37    
  38    instance Corecursive Expr where
  39        embed = \ case
  40            EVarF v  -> EVar v
  41            ENumF n  -> ENum n
  42            EApF s t -> EAp s t
  43    
  44    type ScDefn = (Name, [Name], Expr)
  45    
  46    isInfix :: String -> Bool
  47    isInfix = (&&) <$> not . ("." ==) <*> all (`elem` symbols) 
  48    
  49    symbols, symbols' :: String
  50    symbols = ".<>=+-*/#$%^&:"
  51    symbols' = tail symbols
  52    
  53    instance Show Expr where
  54        showsPrec p = \ case
  55            EVar v -> showString v
  56            ENum n -> showString (show n)
  57            EAp s t -> case s of
  58                EAp (EVar o) s'
  59                    | isInfix o
  60                        -> showParen (p > q) 
  61                            ( showsPreq q s' 
  62                            . showSpace
  63                            . showString o
  64                            . showSpace
  65                            . showPrec (succ q) t
  66                            )
  67                    where
  68                        q = prec o
  69                _ -> showsPrec p s . showSpace . showsPrec 11 t
  70    
  71    showString :: String -> ShowS
  72    showString = (++)
  73    
  74    prec :: String -> Int
  75    prec o = maybe 9 id (lookup o tbl) where
  76        tbl = [ ("$" , 0)
  77              , ("||", 1)
  78              , ("&&", 2)
  79              , ("<" , 3)
  80              , ("<=", 3)
  81              , (">" , 3)
  82              , (">=", 3)
  83              , ("==", 3)
  84              , ("/=", 3)
  85              , ("+" , 4)
  86              , ("-" , 4)
  87              , ("*" , 5)
  88              , ("/" , 5)
  89              , ("^" , 6)
  90              , ("." , 9)
  91              ]
  92    
  93    -- Parser
  94    
  95    parse :: ReadP a -> ReadS a
  96    parse = readP_to_S
  97    
  98    token :: ReadP a -> ReadP a
  99    token = (skipSpaces *>)
 100    
 101    pMunch :: ReadP a -> ReadP [a]
 102    pMunch p = pMunch1 p <++ pure []
 103    
 104    pMunch1 :: ReadP a -> ReadP [a]
 105    pMunch1 p = (:) <$> p <*> pMunch p
 106    
 107    --
 108    
 109    pBop :: Name -> ReadP (Expr -> Expr -> Expr)
 110    pBop op = (EAp .) . (EAp . EVar) <$> (token (string op))
 111    
 112    pExpr :: ReadP Expr
 113    pExpr = chainr1 pExpr1 (pBop "||")
 114    
 115    pExpr1 :: ReadP Expr
 116    pExpr1 = chainr1 pExpr2 (pBop "&&")
 117    
 118    mkBop :: Expr -> Name -> Expr -> Expr
 119    mkBop e1 o e2 = EAp (EAp (EVar o) e1) e2
 120    
 121    pExpr2 :: ReadP Expr
 122    pExpr2 = foldl1 EAp <$> pMunch1 pAExpr
 123    
 124    pAExpr :: ReadP Expr
 125    pAExpr = pENum +++ pEVar +++ between (char '(') (char ')') pExpr
 126    
 127    pENum :: ReadP Expr
 128    pENum = token (ENum . read <$> munch1 isDigit)
 129    
 130    pEVar :: ReadP Expr
 131    pEVar = token (EVar <$> ((:) <$> satisfy isAlpha <*> munch isAlphaNum))
 132    
 133    test :: String
 134    test = "True && False && True"
 135    
 136    relops :: [String]
 137    relops = [ "<"
 138             , "<="
 139             , ">="
 140             , ">"
 141             , "=="
 142             , "/="
 143             ]
 144    
 145    instance Read Expr where
 146        readsPrec _ = readP_to_S pExpr
[1 of 1] Compiling Expr             ( src/Expr.hs, interpreted )

[;1msrc/Expr.hs:55:19: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m
    Ambiguous occurrence ‘showString’
    It could refer to
       either ‘Prelude.showString’,
              imported from ‘Prelude’ at src/Expr.hs:1:8-11
              (and originally defined in ‘GHC.Show’)
           or ‘Expr.showString’, defined at src/Expr.hs:72:1[0m[0m
[;1m[34m   |[0m[0m
[;1m[34m55 |[0m[0m         EVar v -> [;1m[31mshowString[0m[0m v
[;1m[34m   |[0m[0m[;1m[31m                   ^^^^^^^^^^[0m[0m

[;1msrc/Expr.hs:56:19: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m
    Ambiguous occurrence ‘showString’
    It could refer to
       either ‘Prelude.showString’,
              imported from ‘Prelude’ at src/Expr.hs:1:8-11
              (and originally defined in ‘GHC.Show’)
           or ‘Expr.showString’, defined at src/Expr.hs:72:1[0m[0m
[;1m[34m   |[0m[0m
[;1m[34m56 |[0m[0m         ENum n -> [;1m[31mshowString[0m[0m (show n)
[;1m[34m   |[0m[0m[;1m[31m                   ^^^^^^^^^^[0m[0m

[;1msrc/Expr.hs:63:27: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m
    Ambiguous occurrence ‘showString’
    It could refer to
       either ‘Prelude.showString’,
              imported from ‘Prelude’ at src/Expr.hs:1:8-11
              (and originally defined in ‘GHC.Show’)
           or ‘Expr.showString’, defined at src/Expr.hs:72:1[0m[0m
[;1m[34m   |[0m[0m
[;1m[34m63 |[0m[0m                         . [;1m[31mshowString[0m[0m o
[;1m[34m   |[0m[0m[;1m[31m                           ^^^^^^^^^^[0m[0m
Failed, no modules loaded.
2023-05-17 17:33:49.56961187
[?1h=>>> :t showStringE[?1l>showString :: String -> ShowS
2023-05-17 17:34:43.731840207
[?1h=>>> :rE[?1l>   1    module Expr where
   2    
   3    import Data.Bool
   4    import Data.Char
   5    import Data.List (nub)
   6    import Data.Functor.Foldable
   7    import Text.ParserCombinators.ReadP
   8    import Text.PrettyPrint (Doc, (<+>))
   9    import qualified Text.PrettyPrint as PP
  10    
  11    type Name = String
  12    
  13    data Expr
  14        = EVar Name
  15        | ENum Int
  16        | EAp Expr Expr
  17        deriving (Eq)
  18    
  19    isAtom :: Expr -> Bool
  20    isAtom = \ case
  21        EAp _ _ -> False
  22        _       -> True
  23    
  24    data ExprF r
  25        = EVarF Name
  26        | ENumF Int
  27        | EApF r r
  28        deriving (Functor)
  29    
  30    type instance Base Expr = ExprF
  31    
  32    instance Recursive Expr where
  33        project = \ case
  34            EVar v -> EVarF v
  35            ENum n -> ENumF n
  36            EAp s t -> EApF s t
  37    
  38    instance Corecursive Expr where
  39        embed = \ case
  40            EVarF v  -> EVar v
  41            ENumF n  -> ENum n
  42            EApF s t -> EAp s t
  43    
  44    type ScDefn = (Name, [Name], Expr)
  45    
  46    isInfix :: String -> Bool
  47    isInfix = (&&) <$> not . ("." ==) <*> all (`elem` symbols) 
  48    
  49    symbols, symbols' :: String
  50    symbols = ".<>=+-*/#$%^&:"
  51    symbols' = tail symbols
  52    
  53    instance Show Expr where
  54        showsPrec p = \ case
  55            EVar v -> showString v
  56            ENum n -> showString (show n)
  57            EAp s t -> case s of
  58                EAp (EVar o) s'
  59                    | isInfix o
  60                        -> showParen (p > q) 
  61                            ( showsPreq q s' 
  62                            . showSpace
  63                            . showString o
  64                            . showSpace
  65                            . showPrec (succ q) t
  66                            )
  67                    where
  68                        q = prec o
  69                _ -> showsPrec p s . showSpace . showsPrec 11 t
  70    
  71    prec :: String -> Int
  72    prec o = maybe 9 id (lookup o tbl) where
  73        tbl = [ ("$" , 0)
  74              , ("||", 1)
  75              , ("&&", 2)
  76              , ("<" , 3)
  77              , ("<=", 3)
  78              , (">" , 3)
  79              , (">=", 3)
  80              , ("==", 3)
  81              , ("/=", 3)
  82              , ("+" , 4)
  83              , ("-" , 4)
  84              , ("*" , 5)
  85              , ("/" , 5)
  86              , ("^" , 6)
  87              , ("." , 9)
  88              ]
  89    
  90    -- Parser
  91    
  92    parse :: ReadP a -> ReadS a
  93    parse = readP_to_S
  94    
  95    token :: ReadP a -> ReadP a
  96    token = (skipSpaces *>)
  97    
  98    pMunch :: ReadP a -> ReadP [a]
  99    pMunch p = pMunch1 p <++ pure []
 100    
 101    pMunch1 :: ReadP a -> ReadP [a]
 102    pMunch1 p = (:) <$> p <*> pMunch p
 103    
 104    --
 105    
 106    pBop :: Name -> ReadP (Expr -> Expr -> Expr)
 107    pBop op = (EAp .) . (EAp . EVar) <$> (token (string op))
 108    
 109    pExpr :: ReadP Expr
 110    pExpr = chainr1 pExpr1 (pBop "||")
 111    
 112    pExpr1 :: ReadP Expr
 113    pExpr1 = chainr1 pExpr2 (pBop "&&")
 114    
 115    mkBop :: Expr -> Name -> Expr -> Expr
 116    mkBop e1 o e2 = EAp (EAp (EVar o) e1) e2
 117    
 118    pExpr2 :: ReadP Expr
 119    pExpr2 = foldl1 EAp <$> pMunch1 pAExpr
 120    
 121    pAExpr :: ReadP Expr
 122    pAExpr = pENum +++ pEVar +++ between (char '(') (char ')') pExpr
 123    
 124    pENum :: ReadP Expr
 125    pENum = token (ENum . read <$> munch1 isDigit)
 126    
 127    pEVar :: ReadP Expr
 128    pEVar = token (EVar <$> ((:) <$> satisfy isAlpha <*> munch isAlphaNum))
 129    
 130    test :: String
 131    test = "True && False && True"
 132    
 133    relops :: [String]
 134    relops = [ "<"
 135             , "<="
 136             , ">="
 137             , ">"
 138             , "=="
 139             , "/="
 140             ]
 141    
 142    instance Read Expr where
 143        readsPrec _ = readP_to_S pExpr
[1 of 1] Compiling Expr             ( src/Expr.hs, interpreted )

[;1msrc/Expr.hs:61:27: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m
    • Variable not in scope: showsPreq :: Int -> Expr -> b1 -> String
    • Perhaps you meant ‘showsPrec’ (imported from Prelude)[0m[0m
[;1m[34m   |[0m[0m
[;1m[34m61 |[0m[0m                         ( [;1m[31mshowsPreq[0m[0m q s' 
[;1m[34m   |[0m[0m[;1m[31m                           ^^^^^^^^^[0m[0m

[;1msrc/Expr.hs:62:27: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m
    Variable not in scope: showSpace :: String -> b1[0m[0m
[;1m[34m   |[0m[0m
[;1m[34m62 |[0m[0m                         . [;1m[31mshowSpace[0m[0m
[;1m[34m   |[0m[0m[;1m[31m                           ^^^^^^^^^[0m[0m

[;1msrc/Expr.hs:64:27: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m
    Variable not in scope: showSpace :: b0 -> String[0m[0m
[;1m[34m   |[0m[0m
[;1m[34m64 |[0m[0m                         . [;1m[31mshowSpace[0m[0m
[;1m[34m   |[0m[0m[;1m[31m                           ^^^^^^^^^[0m[0m

[;1msrc/Expr.hs:65:27: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m
    • Variable not in scope: showPrec :: Int -> Expr -> String -> b0
    • Perhaps you meant one of these:
        ‘showsPrec’ (imported from Prelude),
        ‘showParen’ (imported from Prelude)[0m[0m
[;1m[34m   |[0m[0m
[;1m[34m65 |[0m[0m                         . [;1m[31mshowPrec[0m[0m (succ q) t
[;1m[34m   |[0m[0m[;1m[31m                           ^^^^^^^^[0m[0m

[;1msrc/Expr.hs:69:34: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m
    Variable not in scope: showSpace :: String -> String[0m[0m
[;1m[34m   |[0m[0m
[;1m[34m69 |[0m[0m             _ -> showsPrec p s . [;1m[31mshowSpace[0m[0m . showsPrec 11 t
[;1m[34m   |[0m[0m[;1m[31m                                  ^^^^^^^^^[0m[0m
Failed, no modules loaded.
2023-05-17 17:34:55.282753209
[?1h=>>> :t showSpaceE[?1l>
[;1m<interactive>:1:1: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m Variable not in scope: showSpace[0m[0m
2023-05-17 17:35:15.597915868
[?1h=>>> showsSpaceE[?1l>
[;1m<interactive>:15:1: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m Variable not in scope: showsSpace[0m[0m
2023-05-17 17:35:34.646933901
[?1h=>>> showChar 'a' ""E[?1l>"a"
2023-05-17 17:36:03.512914017
[?1h=>>> :rE[?1l>   1    module Expr where
   2    
   3    import Data.Bool
   4    import Data.Char
   5    import Data.List (nub)
   6    import Data.Functor.Foldable
   7    import Text.ParserCombinators.ReadP
   8    import Text.PrettyPrint (Doc, (<+>))
   9    import qualified Text.PrettyPrint as PP
  10    
  11    type Name = String
  12    
  13    data Expr
  14        = EVar Name
  15        | ENum Int
  16        | EAp Expr Expr
  17        deriving (Eq)
  18    
  19    isAtom :: Expr -> Bool
  20    isAtom = \ case
  21        EAp _ _ -> False
  22        _       -> True
  23    
  24    data ExprF r
  25        = EVarF Name
  26        | ENumF Int
  27        | EApF r r
  28        deriving (Functor)
  29    
  30    type instance Base Expr = ExprF
  31    
  32    instance Recursive Expr where
  33        project = \ case
  34            EVar v -> EVarF v
  35            ENum n -> ENumF n
  36            EAp s t -> EApF s t
  37    
  38    instance Corecursive Expr where
  39        embed = \ case
  40            EVarF v  -> EVar v
  41            ENumF n  -> ENum n
  42            EApF s t -> EAp s t
  43    
  44    type ScDefn = (Name, [Name], Expr)
  45    
  46    isInfix :: String -> Bool
  47    isInfix = (&&) <$> not . ("." ==) <*> all (`elem` symbols) 
  48    
  49    symbols, symbols' :: String
  50    symbols = ".<>=+-*/#$%^&:"
  51    symbols' = tail symbols
  52    
  53    instance Show Expr where
  54        showsPrec p = \ case
  55            EVar v -> showString v
  56            ENum n -> showString (show n)
  57            EAp s t -> case s of
  58                EAp (EVar o) s'
  59                    | isInfix o
  60                        -> showParen (p > q) 
  61                            ( showsPreq q s' 
  62                            . showSpace
  63                            . showString o
  64                            . showSpace
  65                            . showPrec (succ q) t
  66                            )
  67                    where
  68                        q = prec o
  69                _ -> showsPrec p s . showSpace . showsPrec 11 t
  70    
  71    showSpace :: ShowS
  72    showSpace = showChar ' '
  73    
  74    prec :: String -> Int
  75    prec o = maybe 9 id (lookup o tbl) where
  76        tbl = [ ("$" , 0)
  77              , ("||", 1)
  78              , ("&&", 2)
  79              , ("<" , 3)
  80              , ("<=", 3)
  81              , (">" , 3)
  82              , (">=", 3)
  83              , ("==", 3)
  84              , ("/=", 3)
  85              , ("+" , 4)
  86              , ("-" , 4)
  87              , ("*" , 5)
  88              , ("/" , 5)
  89              , ("^" , 6)
  90              , ("." , 9)
  91              ]
  92    
  93    -- Parser
  94    
  95    parse :: ReadP a -> ReadS a
  96    parse = readP_to_S
  97    
  98    token :: ReadP a -> ReadP a
  99    token = (skipSpaces *>)
 100    
 101    pMunch :: ReadP a -> ReadP [a]
 102    pMunch p = pMunch1 p <++ pure []
 103    
 104    pMunch1 :: ReadP a -> ReadP [a]
 105    pMunch1 p = (:) <$> p <*> pMunch p
 106    
 107    --
 108    
 109    pBop :: Name -> ReadP (Expr -> Expr -> Expr)
 110    pBop op = (EAp .) . (EAp . EVar) <$> (token (string op))
 111    
 112    pExpr :: ReadP Expr
 113    pExpr = chainr1 pExpr1 (pBop "||")
 114    
 115    pExpr1 :: ReadP Expr
 116    pExpr1 = chainr1 pExpr2 (pBop "&&")
 117    
 118    mkBop :: Expr -> Name -> Expr -> Expr
 119    mkBop e1 o e2 = EAp (EAp (EVar o) e1) e2
 120    
 121    pExpr2 :: ReadP Expr
 122    pExpr2 = foldl1 EAp <$> pMunch1 pAExpr
 123    
 124    pAExpr :: ReadP Expr
 125    pAExpr = pENum +++ pEVar +++ between (char '(') (char ')') pExpr
 126    
 127    pENum :: ReadP Expr
 128    pENum = token (ENum . read <$> munch1 isDigit)
 129    
 130    pEVar :: ReadP Expr
 131    pEVar = token (EVar <$> ((:) <$> satisfy isAlpha <*> munch isAlphaNum))
 132    
 133    test :: String
 134    test = "True && False && True"
 135    
 136    relops :: [String]
 137    relops = [ "<"
 138             , "<="
 139             , ">="
 140             , ">"
 141             , "=="
 142             , "/="
 143             ]
 144    
 145    instance Read Expr where
 146        readsPrec _ = readP_to_S pExpr
[1 of 1] Compiling Expr             ( src/Expr.hs, interpreted )

[;1msrc/Expr.hs:61:27: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m
    • Variable not in scope:
        showsPreq :: Int -> Expr -> String -> String
    • Perhaps you meant ‘showsPrec’ (imported from Prelude)[0m[0m
[;1m[34m   |[0m[0m
[;1m[34m61 |[0m[0m                         ( [;1m[31mshowsPreq[0m[0m q s' 
[;1m[34m   |[0m[0m[;1m[31m                           ^^^^^^^^^[0m[0m

[;1msrc/Expr.hs:65:27: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m
    • Variable not in scope:
        showPrec :: Int -> Expr -> String -> String
    • Perhaps you meant one of these:
        ‘showsPrec’ (imported from Prelude),
        ‘showParen’ (imported from Prelude)[0m[0m
[;1m[34m   |[0m[0m
[;1m[34m65 |[0m[0m                         . [;1m[31mshowPrec[0m[0m (succ q) t
[;1m[34m   |[0m[0m[;1m[31m                           ^^^^^^^^[0m[0m
Failed, no modules loaded.
2023-05-17 17:36:49.486486513
[?1h=>>> :rE[?1l>   1    module Expr where
   2    
   3    import Data.Bool
   4    import Data.Char
   5    import Data.List (nub)
   6    import Data.Functor.Foldable
   7    import Text.ParserCombinators.ReadP
   8    import Text.PrettyPrint (Doc, (<+>))
   9    import qualified Text.PrettyPrint as PP
  10    
  11    type Name = String
  12    
  13    data Expr
  14        = EVar Name
  15        | ENum Int
  16        | EAp Expr Expr
  17        deriving (Eq)
  18    
  19    isAtom :: Expr -> Bool
  20    isAtom = \ case
  21        EAp _ _ -> False
  22        _       -> True
  23    
  24    data ExprF r
  25        = EVarF Name
  26        | ENumF Int
  27        | EApF r r
  28        deriving (Functor)
  29    
  30    type instance Base Expr = ExprF
  31    
  32    instance Recursive Expr where
  33        project = \ case
  34            EVar v -> EVarF v
  35            ENum n -> ENumF n
  36            EAp s t -> EApF s t
  37    
  38    instance Corecursive Expr where
  39        embed = \ case
  40            EVarF v  -> EVar v
  41            ENumF n  -> ENum n
  42            EApF s t -> EAp s t
  43    
  44    type ScDefn = (Name, [Name], Expr)
  45    
  46    isInfix :: String -> Bool
  47    isInfix = (&&) <$> not . ("." ==) <*> all (`elem` symbols) 
  48    
  49    symbols, symbols' :: String
  50    symbols = ".<>=+-*/#$%^&:"
  51    symbols' = tail symbols
  52    
  53    instance Show Expr where
  54        showsPrec p = \ case
  55            EVar v -> showString v
  56            ENum n -> showString (show n)
  57            EAp s t -> case s of
  58                EAp (EVar o) s'
  59                    | isInfix o
  60                        -> showParen (p > q) 
  61                            ( showsPrec q s' 
  62                            . showSpace
  63                            . showString o
  64                            . showSpace
  65                            . showsPrec (succ q) t
  66                            )
  67                    where
  68                        q = prec o
  69                _ -> showsPrec p s . showSpace . showsPrec 11 t
  70    
  71    showSpace :: ShowS
  72    showSpace = showChar ' '
  73    
  74    prec :: String -> Int
  75    prec o = maybe 9 id (lookup o tbl) where
  76        tbl = [ ("$" , 0)
  77              , ("||", 1)
  78              , ("&&", 2)
  79              , ("<" , 3)
  80              , ("<=", 3)
  81              , (">" , 3)
  82              , (">=", 3)
  83              , ("==", 3)
  84              , ("/=", 3)
  85              , ("+" , 4)
  86              , ("-" , 4)
  87              , ("*" , 5)
  88              , ("/" , 5)
  89              , ("^" , 6)
  90              , ("." , 9)
  91              ]
  92    
  93    -- Parser
  94    
  95    parse :: ReadP a -> ReadS a
  96    parse = readP_to_S
  97    
  98    token :: ReadP a -> ReadP a
  99    token = (skipSpaces *>)
 100    
 101    pMunch :: ReadP a -> ReadP [a]
 102    pMunch p = pMunch1 p <++ pure []
 103    
 104    pMunch1 :: ReadP a -> ReadP [a]
 105    pMunch1 p = (:) <$> p <*> pMunch p
 106    
 107    --
 108    
 109    pBop :: Name -> ReadP (Expr -> Expr -> Expr)
 110    pBop op = (EAp .) . (EAp . EVar) <$> (token (string op))
 111    
 112    pExpr :: ReadP Expr
 113    pExpr = chainr1 pExpr1 (pBop "||")
 114    
 115    pExpr1 :: ReadP Expr
 116    pExpr1 = chainr1 pExpr2 (pBop "&&")
 117    
 118    mkBop :: Expr -> Name -> Expr -> Expr
 119    mkBop e1 o e2 = EAp (EAp (EVar o) e1) e2
 120    
 121    pExpr2 :: ReadP Expr
 122    pExpr2 = foldl1 EAp <$> pMunch1 pAExpr
 123    
 124    pAExpr :: ReadP Expr
 125    pAExpr = pENum +++ pEVar +++ between (char '(') (char ')') pExpr
 126    
 127    pENum :: ReadP Expr
 128    pENum = token (ENum . read <$> munch1 isDigit)
 129    
 130    pEVar :: ReadP Expr
 131    pEVar = token (EVar <$> ((:) <$> satisfy isAlpha <*> munch isAlphaNum))
 132    
 133    test :: String
 134    test = "True && False && True"
 135    
 136    relops :: [String]
 137    relops = [ "<"
 138             , "<="
 139             , ">="
 140             , ">"
 141             , "=="
 142             , "/="
 143             ]
 144    
 145    instance Read Expr where
 146        readsPrec _ = readP_to_S pExpr
[1 of 1] Compiling Expr             ( src/Expr.hs, interpreted )
Ok, one module loaded.
2023-05-17 17:37:17.159414949
[?1h=>>> show testE[?1l>"\"True && False && True\""
2023-05-17 17:37:35.238842694
[?1h=>>> print s[K$ show testE[?1l>"\"True && False && True\""
2023-05-17 17:38:15.771470935
[?1h=>>> :rE[?1l>   1    module Expr where
   2    
   3    import Data.Bool
   4    import Data.Char
   5    import Data.List (nub)
   6    import Data.Functor.Foldable
   7    import Text.ParserCombinators.ReadP
   8    import Text.PrettyPrint (Doc, (<+>))
   9    import qualified Text.PrettyPrint as PP
  10    
  11    type Name = String
  12    
  13    data Expr
  14        = EVar Name
  15        | ENum Int
  16        | EAp Expr Expr
  17        deriving (Eq)
  18    
  19    isAtom :: Expr -> Bool
  20    isAtom = \ case
  21        EAp _ _ -> False
  22        _       -> True
  23    
  24    data ExprF r
  25        = EVarF Name
  26        | ENumF Int
  27        | EApF r r
  28        deriving (Functor)
  29    
  30    type instance Base Expr = ExprF
  31    
  32    instance Recursive Expr where
  33        project = \ case
  34            EVar v -> EVarF v
  35            ENum n -> ENumF n
  36            EAp s t -> EApF s t
  37    
  38    instance Corecursive Expr where
  39        embed = \ case
  40            EVarF v  -> EVar v
  41            ENumF n  -> ENum n
  42            EApF s t -> EAp s t
  43    
  44    type ScDefn = (Name, [Name], Expr)
  45    
  46    isInfix :: String -> Bool
  47    isInfix = (&&) <$> not . ("." ==) <*> all (`elem` symbols) 
  48    
  49    symbols, symbols' :: String
  50    symbols = ".<>=+-*/#$%^&:"
  51    symbols' = tail symbols
  52    
  53    instance Show Expr where
  54        showsPrec p = \ case
  55            EVar v -> showString v
  56            ENum n -> showString (show n)
  57            EAp s t -> case s of
  58                EAp (EVar o) s'
  59                    | isInfix o
  60                        -> showParen (p > q) 
  61                            ( showsPrec q s' 
  62                            . showSpace
  63                            . showString o
  64                            . showSpace
  65                            . showsPrec (succ q) t
  66                            )
  67                    where
  68                        q = prec o
  69                _ -> showsPrec p s . showSpace . showsPrec 11 t
  70    
  71    showSpace :: ShowS
  72    showSpace = showChar ' '
  73    
  74    showString' :: String -> ShowS
  75    showString' = (++)
  76    
  77    prec :: String -> Int
  78    prec o = maybe 9 id (lookup o tbl) where
  79        tbl = [ ("$" , 0)
  80              , ("||", 1)
  81              , ("&&", 2)
  82              , ("<" , 3)
  83              , ("<=", 3)
  84              , (">" , 3)
  85              , (">=", 3)
  86              , ("==", 3)
  87              , ("/=", 3)
  88              , ("+" , 4)
  89              , ("-" , 4)
  90              , ("*" , 5)
  91              , ("/" , 5)
  92              , ("^" , 6)
  93              , ("." , 9)
  94              ]
  95    
  96    -- Parser
  97    
  98    parse :: ReadP a -> ReadS a
  99    parse = readP_to_S
 100    
 101    token :: ReadP a -> ReadP a
 102    token = (skipSpaces *>)
 103    
 104    pMunch :: ReadP a -> ReadP [a]
 105    pMunch p = pMunch1 p <++ pure []
 106    
 107    pMunch1 :: ReadP a -> ReadP [a]
 108    pMunch1 p = (:) <$> p <*> pMunch p
 109    
 110    --
 111    
 112    pBop :: Name -> ReadP (Expr -> Expr -> Expr)
 113    pBop op = (EAp .) . (EAp . EVar) <$> (token (string op))
 114    
 115    pExpr :: ReadP Expr
 116    pExpr = chainr1 pExpr1 (pBop "||")
 117    
 118    pExpr1 :: ReadP Expr
 119    pExpr1 = chainr1 pExpr2 (pBop "&&")
 120    
 121    mkBop :: Expr -> Name -> Expr -> Expr
 122    mkBop e1 o e2 = EAp (EAp (EVar o) e1) e2
 123    
 124    pExpr2 :: ReadP Expr
 125    pExpr2 = foldl1 EAp <$> pMunch1 pAExpr
 126    
 127    pAExpr :: ReadP Expr
 128    pAExpr = pENum +++ pEVar +++ between (char '(') (char ')') pExpr
 129    
 130    pENum :: ReadP Expr
 131    pENum = token (ENum . read <$> munch1 isDigit)
 132    
 133    pEVar :: ReadP Expr
 134    pEVar = token (EVar <$> ((:) <$> satisfy isAlpha <*> munch isAlphaNum))
 135    
 136    test :: String
 137    test = "True && False && True"
 138    
 139    relops :: [String]
 140    relops = [ "<"
 141             , "<="
 142             , ">="
 143             , ">"
 144             , "=="
 145             , "/="
 146             ]
 147    
 148    instance Read Expr where
 149        readsPrec _ = readP_to_S pExpr
[1 of 1] Compiling Expr             ( src/Expr.hs, interpreted )
Ok, one module loaded.
2023-05-17 17:39:15.932954057
[?1h=>>> :rE[?1l>   1    module Expr where
   2    
   3    import Data.Bool
   4    import Data.Char
   5    import Data.List (nub)
   6    import Data.Functor.Foldable
   7    import Text.ParserCombinators.ReadP
   8    import Text.PrettyPrint (Doc, (<+>))
   9    import qualified Text.PrettyPrint as PP
  10    
  11    type Name = String
  12    
  13    data Expr
  14        = EVar Name
  15        | ENum Int
  16        | EAp Expr Expr
  17        deriving (Eq)
  18    
  19    isAtom :: Expr -> Bool
  20    isAtom = \ case
  21        EAp _ _ -> False
  22        _       -> True
  23    
  24    data ExprF r
  25        = EVarF Name
  26        | ENumF Int
  27        | EApF r r
  28        deriving (Functor)
  29    
  30    type instance Base Expr = ExprF
  31    
  32    instance Recursive Expr where
  33        project = \ case
  34            EVar v -> EVarF v
  35            ENum n -> ENumF n
  36            EAp s t -> EApF s t
  37    
  38    instance Corecursive Expr where
  39        embed = \ case
  40            EVarF v  -> EVar v
  41            ENumF n  -> ENum n
  42            EApF s t -> EAp s t
  43    
  44    type ScDefn = (Name, [Name], Expr)
  45    
  46    isInfix :: String -> Bool
  47    isInfix = (&&) <$> not . ("." ==) <*> all (`elem` symbols) 
  48    
  49    symbols, symbols' :: String
  50    symbols = ".<>=+-*/#$%^&:"
  51    symbols' = tail symbols
  52    
  53    instance Show Expr where
  54        showsPrec p = \ case
  55            EVar v -> showString' v
  56            ENum n -> showString' (show n)
  57            EAp s t -> case s of
  58                EAp (EVar o) s'
  59                    | isInfix o
  60                        -> showParen (p > q) 
  61                            ( showsPrec q s' 
  62                            . showSpace
  63                            . showString' o
  64                            . showSpace
  65                            . showsPrec (succ q) t
  66                            )
  67                    where
  68                        q = prec o
  69                _ -> showsPrec p s . showSpace . showsPrec 11 t
  70    
  71    showSpace :: ShowS
  72    showSpace = showChar ' '
  73    
  74    showString' :: String -> ShowS
  75    showString' = (++)
  76    
  77    prec :: String -> Int
  78    prec o = maybe 9 id (lookup o tbl) where
  79        tbl = [ ("$" , 0)
  80              , ("||", 1)
  81              , ("&&", 2)
  82              , ("<" , 3)
  83              , ("<=", 3)
  84              , (">" , 3)
  85              , (">=", 3)
  86              , ("==", 3)
  87              , ("/=", 3)
  88              , ("+" , 4)
  89              , ("-" , 4)
  90              , ("*" , 5)
  91              , ("/" , 5)
  92              , ("^" , 6)
  93              , ("." , 9)
  94              ]
  95    
  96    -- Parser
  97    
  98    parse :: ReadP a -> ReadS a
  99    parse = readP_to_S
 100    
 101    token :: ReadP a -> ReadP a
 102    token = (skipSpaces *>)
 103    
 104    pMunch :: ReadP a -> ReadP [a]
 105    pMunch p = pMunch1 p <++ pure []
 106    
 107    pMunch1 :: ReadP a -> ReadP [a]
 108    pMunch1 p = (:) <$> p <*> pMunch p
 109    
 110    --
 111    
 112    pBop :: Name -> ReadP (Expr -> Expr -> Expr)
 113    pBop op = (EAp .) . (EAp . EVar) <$> (token (string op))
 114    
 115    pExpr :: ReadP Expr
 116    pExpr = chainr1 pExpr1 (pBop "||")
 117    
 118    pExpr1 :: ReadP Expr
 119    pExpr1 = chainr1 pExpr2 (pBop "&&")
 120    
 121    mkBop :: Expr -> Name -> Expr -> Expr
 122    mkBop e1 o e2 = EAp (EAp (EVar o) e1) e2
 123    
 124    pExpr2 :: ReadP Expr
 125    pExpr2 = foldl1 EAp <$> pMunch1 pAExpr
 126    
 127    pAExpr :: ReadP Expr
 128    pAExpr = pENum +++ pEVar +++ between (char '(') (char ')') pExpr
 129    
 130    pENum :: ReadP Expr
 131    pENum = token (ENum . read <$> munch1 isDigit)
 132    
 133    pEVar :: ReadP Expr
 134    pEVar = token (EVar <$> ((:) <$> satisfy isAlpha <*> munch isAlphaNum))
 135    
 136    test :: String
 137    test = "True && False && True"
 138    
 139    relops :: [String]
 140    relops = [ "<"
 141             , "<="
 142             , ">="
 143             , ">"
 144             , "=="
 145             , "/="
 146             ]
 147    
 148    instance Read Expr where
 149        readsPrec _ = readP_to_S pExpr
[1 of 1] Compiling Expr             ( src/Expr.hs, interpreted )
Ok, one module loaded.
2023-05-17 17:39:43.668856723
[?1h=>>> :r[2Dprint $ show testE[?1l>"\"True && False && True\""
2023-05-17 17:39:48.292469358
[?1h=>>> putStr [KLn $ show testE[?1l>"True && False && True"
2023-05-17 17:40:18.788877549
[?1h=>>> show testE[?1l>"\"True && False && True\""
2023-05-17 17:41:25.964394565
[?1h=>>> :rE[?1l>   1    module Expr where
   2    
   3    import Data.Bool
   4    import Data.Char
   5    import Data.List (nub)
   6    import Data.Functor.Foldable
   7    import Text.ParserCombinators.ReadP
   8    import Text.PrettyPrint (Doc, (<+>))
   9    import qualified Text.PrettyPrint as PP
  10    
  11    type Name = String
  12    
  13    data Expr
  14        = EVar Name
  15        | ENum Int
  16        | EAp Expr Expr
  17        deriving (Eq)
  18    
  19    isAtom :: Expr -> Bool
  20    isAtom = \ case
  21        EAp _ _ -> False
  22        _       -> True
  23    
  24    data ExprF r
  25        = EVarF Name
  26        | ENumF Int
  27        | EApF r r
  28        deriving (Functor)
  29    
  30    type instance Base Expr = ExprF
  31    
  32    instance Recursive Expr where
  33        project = \ case
  34            EVar v -> EVarF v
  35            ENum n -> ENumF n
  36            EAp s t -> EApF s t
  37    
  38    instance Corecursive Expr where
  39        embed = \ case
  40            EVarF v  -> EVar v
  41            ENumF n  -> ENum n
  42            EApF s t -> EAp s t
  43    
  44    type ScDefn = (Name, [Name], Expr)
  45    
  46    isInfix :: String -> Bool
  47    isInfix = (&&) <$> not . ("." ==) <*> all (`elem` symbols) 
  48    
  49    symbols, symbols' :: String
  50    symbols = ".<>=+-*/#$%^&:"
  51    symbols' = tail symbols
  52    
  53    instance Show Expr where
  54        showsPrec p = \ case
  55            EVar v -> showString' v
  56            ENum n -> showString' (show n)
  57            EAp s t -> case s of
  58                EAp (EVar o) s'
  59                    | isInfix o
  60                        -> showParen (p > q) 
  61                            ( showsPrec q s' 
  62                            . showSpace
  63                            . showString' o
  64                            . showSpace
  65                            . showsPrec (succ q) t
  66                            )
  67                    where
  68                        q = prec o
  69                _ -> showsPrec p s . showSpace . showsPrec 11 t
  70    
  71    showSpace :: ShowS
  72    showSpace = showChar ' '
  73    
  74    showString' :: String -> ShowS
  75    showString' = (++)
  76    
  77    prec :: String -> Int
  78    prec o = maybe 9 id (lookup o tbl) where
  79        tbl = [ ("$" , 0)
  80              , ("||", 1)
  81              , ("&&", 2)
  82              , ("<" , 3)
  83              , ("<=", 3)
  84              , (">" , 3)
  85              , (">=", 3)
  86              , ("==", 3)
  87              , ("/=", 3)
  88              , ("+" , 4)
  89              , ("-" , 4)
  90              , ("*" , 5)
  91              , ("/" , 5)
  92              , ("^" , 6)
  93              , ("." , 9)
  94              ]
  95    
  96    -- Parser
  97    
  98    parse :: ReadP a -> ReadS a
  99    parse = readP_to_S
 100    
 101    token :: ReadP a -> ReadP a
 102    token = (skipSpaces *>)
 103    
 104    pMunch :: ReadP a -> ReadP [a]
 105    pMunch p = pMunch1 p <++ pure []
 106    
 107    pMunch1 :: ReadP a -> ReadP [a]
 108    pMunch1 p = (:) <$> p <*> pMunch p
 109    
 110    --
 111    
 112    pBop :: Name -> ReadP (Expr -> Expr -> Expr)
 113    pBop op = (EAp .) . (EAp . EVar) <$> (token (string op))
 114    
 115    pExpr :: ReadP Expr
 116    pExpr = chainr1 pExpr1 (pBop "||")
 117    
 118    pExpr1 :: ReadP Expr
 119    pExpr1 = chainr1 pExpr2 (pBop "&&")
 120    
 121    mkBop :: Expr -> Name -> Expr -> Expr
 122    mkBop e1 o e2 = EAp (EAp (EVar o) e1) e2
 123    
 124    pExpr2 :: ReadP Expr
 125    pExpr2 = foldl1 EAp <$> pMunch1 pAExpr
 126    
 127    pAExpr :: ReadP Expr
 128    pAExpr = pENum +++ pEVar +++ between (char '(') (char ')') pExpr
 129    
 130    pENum :: ReadP Expr
 131    pENum = token (ENum . read <$> munch1 isDigit)
 132    
 133    pEVar :: ReadP Expr
 134    pEVar = token (EVar <$> ((:) <$> satisfy isAlpha <*> munch isAlphaNum))
 135    
 136    test :: String
 137    test = "True && False && True"
 138    
 139    relops :: [String]
 140    relops = [ "<"
 141             , "<="
 142             , ">="
 143             , ">"
 144             , "=="
 145             , "/="
 146             ]
 147    
 148    instance Read Expr where
 149        readsPrec _ = readP_to_S pExpr
Ok, one module loaded.
2023-05-17 17:42:10.162017377
[?1h=>>> :r[2Dshow testE[?1l>"\"True && False && True\""
2023-05-17 17:42:13.712996817
[?1h=>>> soh[K[Khow EV[K[K$ EVar "a"E[?1l>"a"
2023-05-17 17:42:45.512256911
[?1h=>>> showParen (showsPrec 0 "[K$ Ev[KVar "a"))[KE[?1l>
[;1m<interactive>:29:12: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m
    • Couldn't match type ‘String -> String’ with ‘Bool’
      Expected: Bool
        Actual: ShowS
    • Probable cause: ‘($)’ is applied to too few arguments
      In the first argument of ‘showParen’, namely
        ‘(showsPrec 0 $ EVar "a")’
      In the expression: showParen (showsPrec 0 $ EVar "a")
      In an equation for ‘it’: it = showParen (showsPrec 0 $ EVar "a")[0m[0m
2023-05-17 17:44:11.872634432
[?1h=>>> showParen (showsPrec 0 $ EVar "a")T(showsPrec 0 $ EVar "a")[24Dr(showsPrec 0 $ EVar "a")[24Du(showsPrec 0 $ EVar "a")[24De(showsPrec 0 $ EVar "a")[24D (showsPrec 0 $ EVar "a")[24DE[?1l>
[;1m<interactive>:30:1: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m
    • No instance for (Show ShowS) arising from a use of ‘uprint’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: uprint it[0m[0m
2023-05-17 17:44:31.590756623
[?1h=>>> showParen True (showsPrec 0 $ EVar "a") ""E[?1l>"(a)"
2023-05-17 17:45:15.535063508
[?1h=>>> showsPrec False [12DParen True (showsPrec 0 $ EVar "a") "" (showsPrec 0 $ EVar "a") ""[K[28D (showsPrec 0 $ EVar "a") ""[K[28D (showsPrec 0 $ EVar "a") ""[K[28D (showsPrec 0 $ EVar "a") ""[K[28DF (showsPrec 0 $ EVar "a") ""[28Da (showsPrec 0 $ EVar "a") ""[28Dl (showsPrec 0 $ EVar "a") ""[28Ds (showsPrec 0 $ EVar "a") ""[28De (showsPrec 0 $ EVar "a") ""[28D[28CE[?1l>"a"
2023-05-17 17:46:45.634901937
[?1h=>>> showParen False (showsPrec 0 $ EVar "a") ""[33DTrue (showsPrec 0 $ EVar "a") ""[K[3D[K[29D(showsPrec 0 $ EVar "a")[K[30D $ EVar "a"[K[10Dtest[K[9D:r[K[K[KshowsPrec 0 testE[?1l>
[;1m<interactive>:33:1: [;1m[31merror:[0m[0m[;1m[0m[0m[;1m
    • No instance for (Show ShowS) arising from a use of ‘uprint’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: uprint it[0m[0m
2023-05-17 17:47:51.171598558
[?1h=>>> showsPrec 0 test ""E[?1l>"\"True && False && True\""
2023-05-17 17:47:55.888875906
[?1h=>>> showsPrec 0 test ""(test ""[7Drtest ""[7Detest ""[7Datest ""[7Ddtest ""[7D test ""[7D@test ""[7DEtest ""[7Dxtest ""[7Dptest ""[7Drtest ""[7D test ""[7D[C[C[C[C) ""[3DE[?1l>"True && (False && True)"
2023-05-17 17:48:57.818585652
[?1h=>>> showsPrec 0 (read @Expr test) ""[20Dtest ""[K[3D[K[12DParen False (showsPrec 0 $ EVar "a") ""[33DTrue (showsPrec 0 $ EVar "a") ""[K[3D[K[29D(showsPrec 0 $ EVar "a")[K[30D $ EVar "a"[K[10Dtest[K[9D:r[KE[?1l>   1    module Expr where
   2    
   3    import Data.Bool
   4    import Data.Char
   5    import Data.List (nub)
   6    import Data.Functor.Foldable
   7    import Text.ParserCombinators.ReadP
   8    import Text.PrettyPrint (Doc, (<+>))
   9    import qualified Text.PrettyPrint as PP
  10    
  11    type Name = String
  12    
  13    data Expr
  14        = EVar Name
  15        | ENum Int
  16        | EAp Expr Expr
  17        deriving (Eq)
  18    
  19    isAtom :: Expr -> Bool
  20    isAtom = \ case
  21        EAp _ _ -> False
  22        _       -> True
  23    
  24    data ExprF r
  25        = EVarF Name
  26        | ENumF Int
  27        | EApF r r
  28        deriving (Functor)
  29    
  30    type instance Base Expr = ExprF
  31    
  32    instance Recursive Expr where
  33        project = \ case
  34            EVar v -> EVarF v
  35            ENum n -> ENumF n
  36            EAp s t -> EApF s t
  37    
  38    instance Corecursive Expr where
  39        embed = \ case
  40            EVarF v  -> EVar v
  41            ENumF n  -> ENum n
  42            EApF s t -> EAp s t
  43    
  44    type ScDefn = (Name, [Name], Expr)
  45    
  46    isInfix :: String -> Bool
  47    isInfix = (&&) <$> not . ("." ==) <*> all (`elem` symbols) 
  48    
  49    symbols, symbols' :: String
  50    symbols = ".<>=+-*/#$%^&:"
  51    symbols' = tail symbols
  52    
  53    instance Show Expr where
  54        showsPrec p = \ case
  55            EVar v -> showString' v
  56            ENum n -> showString' (show n)
  57            EAp s t -> case s of
  58                EAp (EVar o) s'
  59                    | isInfix o
  60                        -> showParen (p > q) 
  61                            ( showsPrec q s' 
  62                            . showSpace
  63                            . showString' o
  64                            . showSpace
  65                            . showsPrec (succ q) t
  66                            )
  67                    where
  68                        q = prec o
  69                _ -> showsPrec p s . showSpace . showsPrec p t
  70    
  71    showSpace :: ShowS
  72    showSpace = showChar ' '
  73    
  74    showString' :: String -> ShowS
  75    showString' = (++)
  76    
  77    prec :: String -> Int
  78    prec o = maybe 9 id (lookup o tbl) where
  79        tbl = [ ("$" , 0)
  80              , ("||", 1)
  81              , ("&&", 2)
  82              , ("<" , 3)
  83              , ("<=", 3)
  84              , (">" , 3)
  85              , (">=", 3)
  86              , ("==", 3)
  87              , ("/=", 3)
  88              , ("+" , 4)
  89              , ("-" , 4)
  90              , ("*" , 5)
  91              , ("/" , 5)
  92              , ("^" , 6)
  93              , ("." , 9)
  94              ]
  95    
  96    -- Parser
  97    
  98    parse :: ReadP a -> ReadS a
  99    parse = readP_to_S
 100    
 101    token :: ReadP a -> ReadP a
 102    token = (skipSpaces *>)
 103    
 104    pMunch :: ReadP a -> ReadP [a]
 105    pMunch p = pMunch1 p <++ pure []
 106    
 107    pMunch1 :: ReadP a -> ReadP [a]
 108    pMunch1 p = (:) <$> p <*> pMunch p
 109    
 110    --
 111    
 112    pBop :: Name -> ReadP (Expr -> Expr -> Expr)
 113    pBop op = (EAp .) . (EAp . EVar) <$> (token (string op))
 114    
 115    pExpr :: ReadP Expr
 116    pExpr = chainr1 pExpr1 (pBop "||")
 117    
 118    pExpr1 :: ReadP Expr
 119    pExpr1 = chainr1 pExpr2 (pBop "&&")
 120    
 121    mkBop :: Expr -> Name -> Expr -> Expr
 122    mkBop e1 o e2 = EAp (EAp (EVar o) e1) e2
 123    
 124    pExpr2 :: ReadP Expr
 125    pExpr2 = foldl1 EAp <$> pMunch1 pAExpr
 126    
 127    pAExpr :: ReadP Expr
 128    pAExpr = pENum +++ pEVar +++ between (char '(') (char ')') pExpr
 129    
 130    pENum :: ReadP Expr
 131    pENum = token (ENum . read <$> munch1 isDigit)
 132    
 133    pEVar :: ReadP Expr
 134    pEVar = token (EVar <$> ((:) <$> satisfy isAlpha <*> munch isAlphaNum))
 135    
 136    test :: String
 137    test = "True && False && True"
 138    
 139    relops :: [String]
 140    relops = [ "<"
 141             , "<="
 142             , ">="
 143             , ">"
 144             , "=="
 145             , "/="
 146             ]
 147    
 148    instance Read Expr where
 149        readsPrec _ = readP_to_S pExpr
[1 of 1] Compiling Expr             ( src/Expr.hs, interpreted )
Ok, one module loaded.
2023-05-17 17:49:50.280897173
[?1h=>>> :r[2DshowsPrec 0 (read @Expr test) ""E[?1l>"True && (False && True)"
2023-05-17 17:49:55.31640455
[?1h=>>> showsPrec 0 (read @Expr test) ""[32D:r[KE[?1l>   1    module Expr where
   2    
   3    import Data.Bool
   4    import Data.Char
   5    import Data.List (nub)
   6    import Data.Functor.Foldable
   7    import Text.ParserCombinators.ReadP
   8    import Text.PrettyPrint (Doc, (<+>))
   9    import qualified Text.PrettyPrint as PP
  10    
  11    type Name = String
  12    
  13    data Expr
  14        = EVar Name
  15        | ENum Int
  16        | EAp Expr Expr
  17        deriving (Eq)
  18    
  19    isAtom :: Expr -> Bool
  20    isAtom = \ case
  21        EAp _ _ -> False
  22        _       -> True
  23    
  24    data ExprF r
  25        = EVarF Name
  26        | ENumF Int
  27        | EApF r r
  28        deriving (Functor)
  29    
  30    type instance Base Expr = ExprF
  31    
  32    instance Recursive Expr where
  33        project = \ case
  34            EVar v -> EVarF v
  35            ENum n -> ENumF n
  36            EAp s t -> EApF s t
  37    
  38    instance Corecursive Expr where
  39        embed = \ case
  40            EVarF v  -> EVar v
  41            ENumF n  -> ENum n
  42            EApF s t -> EAp s t
  43    
  44    type ScDefn = (Name, [Name], Expr)
  45    
  46    isInfix :: String -> Bool
  47    isInfix = (&&) <$> not . ("." ==) <*> all (`elem` symbols) 
  48    
  49    symbols, symbols' :: String
  50    symbols = ".<>=+-*/#$%^&:"
  51    symbols' = tail symbols
  52    
  53    instance Show Expr where
  54        showsPrec p = \ case
  55            EVar v -> showString' v
  56            ENum n -> showString' (show n)
  57            EAp s t -> case s of
  58                EAp (EVar o) s'
  59                    | isInfix o
  60                        -> showParen (p > q) 
  61                            ( showsPrec q s' 
  62                            . showSpace
  63                            . showString' o
  64                            . showSpace
  65                            . showsPrec (succ q) t
  66                            )
  67                    where
  68                        q = prec o
  69                _ -> showsPrec 0 s . showSpace . showsPrec 0 t
  70    
  71    showSpace :: ShowS
  72    showSpace = showChar ' '
  73    
  74    showString' :: String -> ShowS
  75    showString' = (++)
  76    
  77    prec :: String -> Int
  78    prec o = maybe 9 id (lookup o tbl) where
  79        tbl = [ ("$" , 0)
  80              , ("||", 1)
  81              , ("&&", 2)
  82              , ("<" , 3)
  83              , ("<=", 3)
  84              , (">" , 3)
  85              , (">=", 3)
  86              , ("==", 3)
  87              , ("/=", 3)
  88              , ("+" , 4)
  89              , ("-" , 4)
  90              , ("*" , 5)
  91              , ("/" , 5)
  92              , ("^" , 6)
  93              , ("." , 9)
  94              ]
  95    
  96    -- Parser
  97    
  98    parse :: ReadP a -> ReadS a
  99    parse = readP_to_S
 100    
 101    token :: ReadP a -> ReadP a
 102    token = (skipSpaces *>)
 103    
 104    pMunch :: ReadP a -> ReadP [a]
 105    pMunch p = pMunch1 p <++ pure []
 106    
 107    pMunch1 :: ReadP a -> ReadP [a]
 108    pMunch1 p = (:) <$> p <*> pMunch p
 109    
 110    --
 111    
 112    pBop :: Name -> ReadP (Expr -> Expr -> Expr)
 113    pBop op = (EAp .) . (EAp . EVar) <$> (token (string op))
 114    
 115    pExpr :: ReadP Expr
 116    pExpr = chainr1 pExpr1 (pBop "||")
 117    
 118    pExpr1 :: ReadP Expr
 119    pExpr1 = chainr1 pExpr2 (pBop "&&")
 120    
 121    mkBop :: Expr -> Name -> Expr -> Expr
 122    mkBop e1 o e2 = EAp (EAp (EVar o) e1) e2
 123    
 124    pExpr2 :: ReadP Expr
 125    pExpr2 = foldl1 EAp <$> pMunch1 pAExpr
 126    
 127    pAExpr :: ReadP Expr
 128    pAExpr = pENum +++ pEVar +++ between (char '(') (char ')') pExpr
 129    
 130    pENum :: ReadP Expr
 131    pENum = token (ENum . read <$> munch1 isDigit)
 132    
 133    pEVar :: ReadP Expr
 134    pEVar = token (EVar <$> ((:) <$> satisfy isAlpha <*> munch isAlphaNum))
 135    
 136    test :: String
 137    test = "True && False && True"
 138    
 139    relops :: [String]
 140    relops = [ "<"
 141             , "<="
 142             , ">="
 143             , ">"
 144             , "=="
 145             , "/="
 146             ]
 147    
 148    instance Read Expr where
 149        readsPrec _ = readP_to_S pExpr
[1 of 1] Compiling Expr             ( src/Expr.hs, interpreted )
Ok, one module loaded.
2023-05-17 17:50:23.570585806
[?1h=>>> :r[2DshowsPrec 0 (read @Expr test) ""E[?1l>"True && (False && True)"
2023-05-17 17:50:26.74351052
[?1h=>>> prec "||"E[?1l>1
2023-05-17 17:51:24.606673393
[?1h=>>> prec "||"[9D[Km[Kprec "||"[9DshowsPrec 0 (read @Expr test) ""[32D:r[KE[?1l>   1    module Expr where
   2    
   3    import Data.Bool
   4    import Data.Char
   5    import Data.List (nub)
   6    import Data.Functor.Foldable
   7    import Text.ParserCombinators.ReadP
   8    import Text.PrettyPrint (Doc, (<+>))
   9    import qualified Text.PrettyPrint as PP
  10    
  11    type Name = String
  12    
  13    data Expr
  14        = EVar Name
  15        | ENum Int
  16        | EAp Expr Expr
  17        deriving (Eq)
  18    
  19    isAtom :: Expr -> Bool
  20    isAtom = \ case
  21        EAp _ _ -> False
  22        _       -> True
  23    
  24    data ExprF r
  25        = EVarF Name
  26        | ENumF Int
  27        | EApF r r
  28        deriving (Functor)
  29    
  30    type instance Base Expr = ExprF
  31    
  32    instance Recursive Expr where
  33        project = \ case
  34            EVar v -> EVarF v
  35            ENum n -> ENumF n
  36            EAp s t -> EApF s t
  37    
  38    instance Corecursive Expr where
  39        embed = \ case
  40            EVarF v  -> EVar v
  41            ENumF n  -> ENum n
  42            EApF s t -> EAp s t
  43    
  44    type ScDefn = (Name, [Name], Expr)
  45    
  46    isInfix :: String -> Bool
  47    isInfix = (&&) <$> not . ("." ==) <*> all (`elem` symbols) 
  48    
  49    symbols, symbols' :: String
  50    symbols = ".<>=+-*/#$%^&:"
  51    symbols' = tail symbols
  52    
  53    instance Show Expr where
  54        showsPrec p = \ case
  55            EVar v -> showString' v
  56            ENum n -> showString' (show n)
  57            EAp s t -> case s of
  58                EAp (EVar o) s'
  59                    | isInfix o
  60                        -> showParen (p > q) 
  61                            ( showsPrec q s' 
  62                            . showSpace
  63                            . showString' o
  64                            . showSpace
  65                            . showsPrec (succ q) t
  66                            )
  67                    where
  68                        q = prec o
  69                _ -> showsPrec p s . showSpace . showsPrec (succ p) t
  70    
  71    showSpace :: ShowS
  72    showSpace = showChar ' '
  73    
  74    showString' :: String -> ShowS
  75    showString' = (++)
  76    
  77    prec :: String -> Int
  78    prec o = maybe 9 id (lookup o tbl) where
  79        tbl = [ ("$" , 0)
  80              , ("||", 1)
  81              , ("&&", 2)
  82              , ("<" , 3)
  83              , ("<=", 3)
  84              , (">" , 3)
  85              , (">=", 3)
  86              , ("==", 3)
  87              , ("/=", 3)
  88              , ("+" , 4)
  89              , ("-" , 4)
  90              , ("*" , 5)
  91              , ("/" , 5)
  92              , ("^" , 6)
  93              , ("." , 7)
  94              ]
  95    
  96    -- Parser
  97    
  98    parse :: ReadP a -> ReadS a
  99    parse = readP_to_S
 100    
 101    token :: ReadP a -> ReadP a
 102    token = (skipSpaces *>)
 103    
 104    pMunch :: ReadP a -> ReadP [a]
 105    pMunch p = pMunch1 p <++ pure []
 106    
 107    pMunch1 :: ReadP a -> ReadP [a]
 108    pMunch1 p = (:) <$> p <*> pMunch p
 109    
 110    --
 111    
 112    pBop :: Name -> ReadP (Expr -> Expr -> Expr)
 113    pBop op = (EAp .) . (EAp . EVar) <$> (token (string op))
 114    
 115    pExpr :: ReadP Expr
 116    pExpr = chainr1 pExpr1 (pBop "||")
 117    
 118    pExpr1 :: ReadP Expr
 119    pExpr1 = chainr1 pExpr2 (pBop "&&")
 120    
 121    mkBop :: Expr -> Name -> Expr -> Expr
 122    mkBop e1 o e2 = EAp (EAp (EVar o) e1) e2
 123    
 124    pExpr2 :: ReadP Expr
 125    pExpr2 = foldl1 EAp <$> pMunch1 pAExpr
 126    
 127    pAExpr :: ReadP Expr
 128    pAExpr = pENum +++ pEVar +++ between (char '(') (char ')') pExpr
 129    
 130    pENum :: ReadP Expr
 131    pENum = token (ENum . read <$> munch1 isDigit)
 132    
 133    pEVar :: ReadP Expr
 134    pEVar = token (EVar <$> ((:) <$> satisfy isAlpha <*> munch isAlphaNum))
 135    
 136    test :: String
 137    test = "True && False && True"
 138    
 139    relops :: [String]
 140    relops = [ "<"
 141             , "<="
 142             , ">="
 143             , ">"
 144             , "=="
 145             , "/="
 146             ]
 147    
 148    instance Read Expr where
 149        readsPrec _ = readP_to_S pExpr
[1 of 1] Compiling Expr             ( src/Expr.hs, interpreted )
Ok, one module loaded.
2023-05-17 17:55:24.013581026
[?1h=>>> :r[2Dprec "||"[9DshowsPrec 0 (read @Expr test) ""E[?1l>"True && (False && True)"
2023-05-17 17:55:32.568140092
[?1h=>>> :rE[?1l>   1    module Expr where
   2    
   3    import Data.Bool
   4    import Data.Char
   5    import Data.List (nub)
   6    import Data.Functor.Foldable
   7    import Text.ParserCombinators.ReadP
   8    import Text.PrettyPrint (Doc, (<+>))
   9    import qualified Text.PrettyPrint as PP
  10    
  11    type Name = String
  12    
  13    data Expr
  14        = EVar Name
  15        | ENum Int
  16        | EAp Expr Expr
  17        deriving (Eq)
  18    
  19    isAtom :: Expr -> Bool
  20    isAtom = \ case
  21        EAp _ _ -> False
  22        _       -> True
  23    
  24    data ExprF r
  25        = EVarF Name
  26        | ENumF Int
  27        | EApF r r
  28        deriving (Functor)
  29    
  30    type instance Base Expr = ExprF
  31    
  32    instance Recursive Expr where
  33        project = \ case
  34            EVar v -> EVarF v
  35            ENum n -> ENumF n
  36            EAp s t -> EApF s t
  37    
  38    instance Corecursive Expr where
  39        embed = \ case
  40            EVarF v  -> EVar v
  41            ENumF n  -> ENum n
  42            EApF s t -> EAp s t
  43    
  44    type ScDefn = (Name, [Name], Expr)
  45    
  46    isInfix :: String -> Bool
  47    isInfix = (&&) <$> not . ("." ==) <*> all (`elem` symbols) 
  48    
  49    symbols, symbols' :: String
  50    symbols = ".<>=+-*/#$%^&:"
  51    symbols' = tail symbols
  52    
  53    instance Show Expr where
  54        showsPrec p = \ case
  55            EVar v -> showString' v
  56            ENum n -> showString' (show n)
  57            EAp s t -> case s of
  58                EAp (EVar o) s'
  59                    | isInfix o
  60                        -> showParen (p > q) 
  61                            ( showsPrec q' s' 
  62                            . showSpace
  63                            . showString' o
  64                            . showSpace
  65                            . showsPrec q'' t
  66                            )
  67                    where
  68                        q = prec o
  69                        d = adir o
  70                        (q', q'') = case d of
  71                            L -> (succ q, q)
  72                            I -> (succ q, succ q)
  73                            R -> (q, succ q)
  74                _ -> showsPrec p s . showSpace . showsPrec (succ p) t
  75    
  76    showSpace :: ShowS
  77    showSpace = showChar ' '
  78    
  79    showString' :: String -> ShowS
  80    showString' = (++)
  81    
  82    data Fixity
  83        = L
  84        | I
  85        | R
  86    
  87    prec :: String -> Int
  88    prec o = maybe 9 snd (lookup o tbl)
  89    
  90    adir :: String -> Fixity
  91    adir o = maybe L fst (lookup o tbl)
  92    
  93    tbl :: [(String, (Fixity, Int))]
  94    tbl = [ ("$" , (R, 0))
  95              , ("||", (R, 1))
  96              , ("&&", (R, 2))
  97              , ("<" , (I, 3))
  98              , ("<=", (I, 3))
  99              , (">" , (I, 3))
 100              , (">=", (I, 3))
 101              , ("==", (I, 3))
 102              , ("/=", (I, 3))
 103              , ("+" , (L, 4))
 104              , ("-" , (L, 4))
 105              , ("*" , (L, 5))
 106              , ("/" , (L, 5))
 107              , ("^" , (R, 6))
 108              , ("." , (R, 7))
 109              ]
 110    
 111    -- Parser
 112    
 113    parse :: ReadP a -> ReadS a
 114    parse = readP_to_S
 115    
 116    token :: ReadP a -> ReadP a
 117    token = (skipSpaces *>)
 118    
 119    pMunch :: ReadP a -> ReadP [a]
 120    pMunch p = pMunch1 p <++ pure []
 121    
 122    pMunch1 :: ReadP a -> ReadP [a]
 123    pMunch1 p = (:) <$> p <*> pMunch p
 124    
 125    --
 126    
 127    pBop :: Name -> ReadP (Expr -> Expr -> Expr)
 128    pBop op = (EAp .) . (EAp . EVar) <$> (token (string op))
 129    
 130    pExpr :: ReadP Expr
 131    pExpr = chainr1 pExpr1 (pBop "||")
 132    
 133    pExpr1 :: ReadP Expr
 134    pExpr1 = chainr1 pExpr2 (pBop "&&")
 135    
 136    mkBop :: Expr -> Name -> Expr -> Expr
 137    mkBop e1 o e2 = EAp (EAp (EVar o) e1) e2
 138    
 139    pExpr2 :: ReadP Expr
 140    pExpr2 = foldl1 EAp <$> pMunch1 pAExpr
 141    
 142    pAExpr :: ReadP Expr
 143    pAExpr = pENum +++ pEVar +++ between (char '(') (char ')') pExpr
 144    
 145    pENum :: ReadP Expr
 146    pENum = token (ENum . read <$> munch1 isDigit)
 147    
 148    pEVar :: ReadP Expr
 149    pEVar = token (EVar <$> ((:) <$> satisfy isAlpha <*> munch isAlphaNum))
 150    
 151    test :: String
 152    test = "True && False && True"
 153    
 154    relops :: [String]
 155    relops = [ "<"
 156             , "<="
 157             , ">="
 158             , ">"
 159             , "=="
 160             , "/="
 161             ]
 162    
 163    instance Read Expr where
 164        readsPrec _ = readP_to_S pExpr
[1 of 1] Compiling Expr             ( src/Expr.hs, interpreted )
Ok, one module loaded.
2023-05-17 19:42:12.822635575
[?1h=>>> :r[2DshowsPrec 0 (read @Expr test) ""[32D:r[KE[?1l>   1    module Expr where
   2    
   3    import Data.Bool
   4    import Data.Char
   5    import Data.List (nub)
   6    import Data.Functor.Foldable
   7    import Text.ParserCombinators.ReadP
   8    import Text.PrettyPrint (Doc, (<+>))
   9    import qualified Text.PrettyPrint as PP
  10    
  11    type Name = String
  12    
  13    data Expr
  14        = EVar Name
  15        | ENum Int
  16        | EAp Expr Expr
  17        deriving (Eq)
  18    
  19    isAtom :: Expr -> Bool
  20    isAtom = \ case
  21        EAp _ _ -> False
  22        _       -> True
  23    
  24    data ExprF r
  25        = EVarF Name
  26        | ENumF Int
  27        | EApF r r
  28        deriving (Functor)
  29    
  30    type instance Base Expr = ExprF
  31    
  32    instance Recursive Expr where
  33        project = \ case
  34            EVar v -> EVarF v
  35            ENum n -> ENumF n
  36            EAp s t -> EApF s t
  37    
  38    instance Corecursive Expr where
  39        embed = \ case
  40            EVarF v  -> EVar v
  41            ENumF n  -> ENum n
  42            EApF s t -> EAp s t
  43    
  44    type ScDefn = (Name, [Name], Expr)
  45    
  46    isInfix :: String -> Bool
  47    isInfix = (&&) <$> not . ("." ==) <*> all (`elem` symbols) 
  48    
  49    symbols, symbols' :: String
  50    symbols = ".<>=+-*/#$%^&:"
  51    symbols' = tail symbols
  52    
  53    instance Show Expr where
  54        showsPrec p = \ case
  55            EVar v -> showString' v
  56            ENum n -> showString' (show n)
  57            EAp s t -> case s of
  58                EAp (EVar o) s'
  59                    | isInfix o
  60                        -> showParen (p > q) 
  61                            ( showsPrec q' s' 
  62                            . showSpace
  63                            . showString' o
  64                            . showSpace
  65                            . showsPrec q'' t
  66                            )
  67                    where
  68                        q = prec o
  69                        d = adir o
  70                        (q', q'') = case d of
  71                            L -> (q, succ q)
  72                            I -> (succ q, succ q)
  73                            R -> (succ q, q)
  74                _ -> showsPrec p s . showSpace . showsPrec (succ p) t
  75    
  76    showSpace :: ShowS
  77    showSpace = showChar ' '
  78    
  79    showString' :: String -> ShowS
  80    showString' = (++)
  81    
  82    data Fixity
  83        = L
  84        | I
  85        | R
  86    
  87    prec :: String -> Int
  88    prec o = maybe 9 snd (lookup o tbl)
  89    
  90    adir :: String -> Fixity
  91    adir o = maybe L fst (lookup o tbl)
  92    
  93    tbl :: [(String, (Fixity, Int))]
  94    tbl = [ ("$" , (R, 0))
  95              , ("||", (R, 1))
  96              , ("&&", (R, 2))
  97              , ("<" , (I, 3))
  98              , ("<=", (I, 3))
  99              , (">" , (I, 3))
 100              , (">=", (I, 3))
 101              , ("==", (I, 3))
 102              , ("/=", (I, 3))
 103              , ("+" , (L, 4))
 104              , ("-" , (L, 4))
 105              , ("*" , (L, 5))
 106              , ("/" , (L, 5))
 107              , ("^" , (R, 6))
 108              , ("." , (R, 7))
 109              ]
 110    
 111    -- Parser
 112    
 113    parse :: ReadP a -> ReadS a
 114    parse = readP_to_S
 115    
 116    token :: ReadP a -> ReadP a
 117    token = (skipSpaces *>)
 118    
 119    pMunch :: ReadP a -> ReadP [a]
 120    pMunch p = pMunch1 p <++ pure []
 121    
 122    pMunch1 :: ReadP a -> ReadP [a]
 123    pMunch1 p = (:) <$> p <*> pMunch p
 124    
 125    --
 126    
 127    pBop :: Name -> ReadP (Expr -> Expr -> Expr)
 128    pBop op = (EAp .) . (EAp . EVar) <$> (token (string op))
 129    
 130    pExpr :: ReadP Expr
 131    pExpr = chainr1 pExpr1 (pBop "||")
 132    
 133    pExpr1 :: ReadP Expr
 134    pExpr1 = chainr1 pExpr2 (pBop "&&")
 135    
 136    mkBop :: Expr -> Name -> Expr -> Expr
 137    mkBop e1 o e2 = EAp (EAp (EVar o) e1) e2
 138    
 139    pExpr2 :: ReadP Expr
 140    pExpr2 = foldl1 EAp <$> pMunch1 pAExpr
 141    
 142    pAExpr :: ReadP Expr
 143    pAExpr = pENum +++ pEVar +++ between (char '(') (char ')') pExpr
 144    
 145    pENum :: ReadP Expr
 146    pENum = token (ENum . read <$> munch1 isDigit)
 147    
 148    pEVar :: ReadP Expr
 149    pEVar = token (EVar <$> ((:) <$> satisfy isAlpha <*> munch isAlphaNum))
 150    
 151    test :: String
 152    test = "True && False && True"
 153    
 154    relops :: [String]
 155    relops = [ "<"
 156             , "<="
 157             , ">="
 158             , ">"
 159             , "=="
 160             , "/="
 161             ]
 162    
 163    instance Read Expr where
 164        readsPrec _ = readP_to_S pExpr
[1 of 1] Compiling Expr             ( src/Expr.hs, interpreted )
Ok, one module loaded.
2023-05-17 19:42:50.551998691
[?1h=>>> :r[2DshowsPrec 0 (read @Expr test) ""E[?1l>"True && False && True"
2023-05-17 19:42:55.697105334
[?1h=>>> :q [KE[?1l>Leaving GHCi.
[1m[7m%[27m[1m[0m                                                                                 [0m[27m[24m[J[4mλ.[24m [K[51C[36mfeature[39m: [4m~/devel/pointfree[24m[77D[?1h=[?2004hsstack build[?1l>[?2004l
[0mpointfree-0.1.0.0: unregistering (local file changes: .stack-work/dist/x86_64-linux-tinfo6/Cabal-3.6.3.0/build/autogen/Paths_pointfree.hs .stack-work/d...)[0m
[0mpointfree> build (lib + exe)[0m
[0mPreprocessing library for pointfree-0.1.0.0..[0m
[0mBuilding library for pointfree-0.1.0.0..[0m
[0m[3 of 4] Compiling Expr[0m
[0m[4 of 4] Compiling PointFree [Expr changed][0m
[0mPreprocessing executable 'pointfree' for pointfree-0.1.0.0..[0m
[0mBuilding executable 'pointfree' for pointfree-0.1.0.0..[0m
[0m[2 of 2] Compiling Main[0m
[0mLinking .stack-work/dist/x86_64-linux-tinfo6/Cabal-3.6.3.0/build/pointfree/pointfree ...[0m
[0mpointfree> copy/register[0m
[0mInstalling library in /home/nobsun/Dropbox/devel/pointfree/.stack-work/install/x86_64-linux-tinfo6/dc24f4120530249ed2f13afca56d5e84e0be5b1a8740238b83e65c9467520b14/9.2.7/lib/x86_64-linux-ghc-9.2.7/pointfree-0.1.0.0-B06nRRmntNB6nnOUD79IYj[0m
[0mInstalling executable pointfree in /home/nobsun/Dropbox/devel/pointfree/.stack-work/install/x86_64-linux-tinfo6/dc24f4120530249ed2f13afca56d5e84e0be5b1a8740238b83e65c9467520b14/9.2.7/bin[0m
[0mRegistering library for pointfree-0.1.0.0..[0m
[1m[7m%[27m[1m[0m                                                                                 [0m[27m[24m[J[4mλ.[24m [K[51C[36mfeature[39m: [4m~/devel/pointfree[24m[77D[?1h=[?2004hggit g  ggit g  sstack build[?1l>[?2004l
[1m[7m%[27m[1m[0m                                                                                 [0m[27m[24m[J[4mλ.[24m [K[51C[36mfeature[39m: [4m~/devel/pointfree[24m[77D[?1h=[?2004hsstack build      exec -- poin          install[?1l>[?2004l
[0mCopying from /home/nobsun/Dropbox/devel/pointfree/.stack-work/install/x86_64-linux-tinfo6/dc24f4120530249ed2f13afca56d5e84e0be5b1a8740238b83e65c9467520b14/9.2.7/bin/pointfree to /home/nobsun/.local/bin/pointfree[0m
[0m[0m
[0mCopied executables to /home/nobsun/.local/bin:[0m
[0m- pointfree[0m
[1m[7m%[27m[1m[0m                                                                                 [0m[27m[24m[J[4mλ.[24m [K[51C[36mfeature[39m: [4m~/devel/pointfree[24m[77D[?1h=[?2004hppointfree "f x = g y x y"[?1l>[?2004l
pointfree: Prelude.read: no parse
[1m[7m%[27m[1m[0m                                                                                 [0m[27m[24m[J[4mλ.[24m [K[51C[36mfeature[39m: [4m~/devel/pointfree[24m[77D[?1h=[?2004hggit checkout main[?1l>[?2004l
error: Your local changes to the following files would be overwritten by checkout:
	src/Expr.hs
	src/PointFree.hs
Please commit your changes or stash them before you switch branches.
Aborting
[1m[7m%[27m[1m[0m                                                                                 [0m[27m[24m[J[4mλ.[24m [K[51C[36mfeature[39m: [4m~/devel/pointfree[24m[77D[?1h=[?2004hggit add .[?1l>[?2004l
